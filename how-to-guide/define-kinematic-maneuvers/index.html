<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>How to Define Kinematic Maneuvers · FLOWUnsteady</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="FLOWUnsteady logo"/></a><div class="docs-package-name"><span class="docs-autofit">FLOWUnsteady</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/getting-started/">Getting Started</a></li><li><a class="tocitem" href="../../tutorials/first-steps/">First Steps</a></li><li><a class="tocitem" href="../../tutorials/aeroacoustics/">Aeroacoustic Noise Analysis</a></li></ul></li><li><span class="tocitem">How to </span><ul><li><a class="tocitem" href="../paraview-visualization/">Visualize with Paraview</a></li><li><a class="tocitem" href="../define-complex-wings/">How to define Complex Wings</a></li><li><a class="tocitem" href="../define-complex-systems/">How to Define Vehicle Systems</a></li><li><a class="tocitem" href="../define-a-rotor/">How to Define a Custom Rotor</a></li><li class="is-active"><a class="tocitem" href>How to Define Kinematic Maneuvers</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Prescribe-a-Kinematic-Maneuver"><span>Prescribe a Kinematic Maneuver</span></a></li><li><a class="tocitem" href="#Generate-a-Maneuver-Object"><span>Generate a Maneuver Object</span></a></li><li><a class="tocitem" href="#Simulate"><span>Simulate</span></a></li></ul></li><li><a class="tocitem" href="../set-up-runtime-functions/">How to Set up Run-time Functions</a></li><li><a class="tocitem" href="../select-a-solver/">Select a Solver</a></li><li><a class="tocitem" href="../wake-stability/">How to Approach Wake Stability Issues</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../../reference/FLOWVLMfunctions/">Functions Contained in FLOWVLM</a></li><li><a class="tocitem" href="../../reference/VPMfunctions/">Functions Contained in MyVPM</a></li><li><a class="tocitem" href="../../reference/FLOWUnsteadyfunctions/">Functions Contained in FLOWUnsteady</a></li></ul></li><li><span class="tocitem">Theory</span><ul><li><a class="tocitem" href="../../theory/FLOWVLMtheory/">FLOWVLM</a></li><li><a class="tocitem" href="../../theory/VPMtheory/">Vortex Particle Method</a></li><li><a class="tocitem" href="../../theory/FLOWUnsteadytheory/">FLOWUnsteady</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">How to </a></li><li class="is-active"><a href>How to Define Kinematic Maneuvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>How to Define Kinematic Maneuvers</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/byuflowlab/FLOWUnsteady/blob/master/docs/src/how-to-guide/define-kinematic-maneuvers.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="How-to-Define-Kinematic-Maneuvers"><a class="docs-heading-anchor" href="#How-to-Define-Kinematic-Maneuvers">How to Define Kinematic Maneuvers</a><a id="How-to-Define-Kinematic-Maneuvers-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-Define-Kinematic-Maneuvers" title="Permalink"></a></h1><p>There are two ways to generate a maneuver in FLOWUnsteady, prescribing a kinematic maneuver and prescribing actions to generate motion. Prescribing a kinematic maneuver, you inform the simulator where the aircraft is moving and the simulator determines the effects. When you prescribe an action, like running the rotors, to the simulator, the simulator then determines the forces on the aircraft that generate motion.</p><h1 id="Prescribe-a-Kinematic-Maneuver"><a class="docs-heading-anchor" href="#Prescribe-a-Kinematic-Maneuver">Prescribe a Kinematic Maneuver</a><a id="Prescribe-a-Kinematic-Maneuver-1"></a><a class="docs-heading-anchor-permalink" href="#Prescribe-a-Kinematic-Maneuver" title="Permalink"></a></h1><p>To prescribe a kinematic maneuver you must generate a maneuver object, setup the simulation, and then simulate. Here we use the kinematic maneuver from the Vahana example to further explain. </p><h2 id="Generate-a-Maneuver-Object"><a class="docs-heading-anchor" href="#Generate-a-Maneuver-Object">Generate a Maneuver Object</a><a id="Generate-a-Maneuver-Object-1"></a><a class="docs-heading-anchor-permalink" href="#Generate-a-Maneuver-Object" title="Permalink"></a></h2><h5 id="Generate-Geometry"><a class="docs-heading-anchor" href="#Generate-Geometry">Generate Geometry</a><a id="Generate-Geometry-1"></a><a class="docs-heading-anchor-permalink" href="#Generate-Geometry" title="Permalink"></a></h5><p>Before generating a simulation object, you must have generated the geometry object. If you are unsure of how to generate geometry, refer to the <a href="how-to-guide/@ref First Steps">tutorial</a>. </p><pre><code class="language-julia"> # Generate geometry
    (vehicle, grounds) = generate_geometry_vahana(; n_factor=1,
                                                    xfoil=false,
                                                    data_path=data_path,
                                                    run_name=run_name,
                                                    optargs...)</code></pre><h5 id="Define-reference-velocity,-RPM,-total-time,-and-number-of-steps"><a class="docs-heading-anchor" href="#Define-reference-velocity,-RPM,-total-time,-and-number-of-steps">Define reference velocity, RPM, total time, and number of steps</a><a id="Define-reference-velocity,-RPM,-total-time,-and-number-of-steps-1"></a><a class="docs-heading-anchor-permalink" href="#Define-reference-velocity,-RPM,-total-time,-and-number-of-steps" title="Permalink"></a></h5><pre><code class="language-julia">    # Maneuver to perform
    Vref = 0.25 * 125*0.44704           # Cruise speed
    RPMref = 100                        # Reference RPM
    ttot = 30.0                         # Total time to perform maneuver
    nsteps = 1500                       # Time steps</code></pre><h5 id="Define-an-Angle-function"><a class="docs-heading-anchor" href="#Define-an-Angle-function">Define an Angle function</a><a id="Define-an-Angle-function-1"></a><a class="docs-heading-anchor-permalink" href="#Define-an-Angle-function" title="Permalink"></a></h5><pre><code class="language-julia">   &quot;&quot;&quot;
        Receives a nondimensional time between 0 and 1, and returns the angles
        (in degrees) of the main wing relative to the aircraft axis.
    &quot;&quot;&quot;
    function angle_main(t)

        # ------------ TAKE OFF ------------------------------------------------
        if t&lt;t1
            return [0, 90, 0]

        # ------------ TRANSITION ----------------------------------------------
        elseif t&lt;t2
            val = 1.5 * (t-t1) / (t2-t1)
            val1 = val + 0.25
            angle_main = 90 - 90*(1-exp(-(val1)^5))
            return [0, angle_main, 0]

        # ------------ CRUISE --------------------------------------------------
        elseif t&lt;t3
            return [0, 0, 0]

        # ------------ TRANSITION ----------------------------------------------
        elseif t&lt;t4
            # Weibull decceleration to hover
            val = 1.5 * (1 - (t-t3) / (t4-t3))
            angle_main = 90 - 90*(1-exp(-(val)^5))
            return [0, angle_main, 0]

        # ------------ LANDING -------------------------------------------------
        else
            return [0, 90, 0]
        end
    end</code></pre><h5 id="Define-RPM-function"><a class="docs-heading-anchor" href="#Define-RPM-function">Define RPM function</a><a id="Define-RPM-function-1"></a><a class="docs-heading-anchor-permalink" href="#Define-RPM-function" title="Permalink"></a></h5><pre><code class="language-julia">&quot;&quot;&quot;
        Receives a nondimensional time between 0 and 1, and returns the
        main wing RPM non-dimensionalized by the hover RPM.
    &quot;&quot;&quot;
    function RPM_main(t)

        # ------------ TAKE OFF ------------------------------------------------
        if t&lt;t1
            # Weibull acceleration to target climb
            if t&lt;t1/2
                val = t / (t1/2)
                RPM_w = RPM1*(1.05-exp(-(5*val)^2))
            # Weibull decceleration to hover
            else
                val = 1 - (t-t1/2) / (t1/2)
                RPM_w = 1.0 + (RPM1-1.0)*(1-exp(-(2*val)^5))
            end

            return RPM_w

        # ------------ TRANSITION ----------------------------------------------
        elseif t&lt;t2
            # Increases RPM to sustain forward flight and hover
            if (t-t1)&lt;(t2-t1)*0.25
                val = (t-t1)/((t2-t1)*0.25)
                RPM_w = 1.0 + (RPM2-1.0)*(1-exp(-(2*val)^5))
            # Decreases RPM as it tilts the wing out of hover support
            else
                val = 1 - ((t2-t)/(t2-t1)-0.25) / (1-0.25)
                RPM_w = RPM2 + (RPM3-RPM2)*(1-exp(-(1.1*val)^5))
            end

            return RPM_w

        # ------------ CRUISE --------------------------------------------------
        elseif t&lt;t3
            RPM_w = RPM3
            return RPM_w

        # ------------ TRANSITION ----------------------------------------------
        elseif t&lt;t4
            # Weibull decceleration to hover
            val = 1.5 * (1 - (t-t3) / (t4-t3))
            RPM_w = RPM4 + (RPM3-RPM4)*(1-exp(-(val)^3))
            return RPM_w

        # ------------ LANDING -------------------------------------------------
        else
            # Weibull acceleration to target descend
            if (t-t4)&lt;(1-t4)*0.55
                val = (t-t4) / ((1-t4)*0.55)
                RPM_w = RPM4 + (RPM5-RPM4)*(1-exp(-(3*val)^5))
            # Weibull decceleration to hover
            else
                val = ((t-t4) - (1-t4)*0.55) / ((1-t4)*(1-0.55))
                val = val + 0.60
                RPM_w = RPM5*(3.0*(val)^(3.0-1)*exp(-(val)^5.0))/1.0
            end

            return RPM_w

        end
    end</code></pre><h5 id="Define-Vehicle-Velocity-Function"><a class="docs-heading-anchor" href="#Define-Vehicle-Velocity-Function">Define Vehicle Velocity Function</a><a id="Define-Vehicle-Velocity-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Define-Vehicle-Velocity-Function" title="Permalink"></a></h5><pre><code class="language-julia"> &quot;&quot;&quot;
        Receives a nondimensional time between 0 and 1, and returns the
        vector of velocity of the aircraft at that instant.
    &quot;&quot;&quot;
    function Vaircraft(t)

        # ------------ TAKE OFF ------------------------------------------------
        if t&lt;t1

            # Weibull acceleration to target climb
            if t&lt;t1/2
                val = t / (t1/2)
                Vz = V0 + V1*(1-exp(-(2*val)^5))
            # Weibull decceleration to hover
            else
                val = 1 - (t-t1/2) / (t1/2)
                Vz = V1*(1-exp(-(2*val)^5))
            end

            return [0, 0, Vz]

        # ------------ TRANSITION ----------------------------------------------
        elseif t&lt;t2

            # Weibull acceleration to cruise
            val = 1.5 * (t-t1) / (t2-t1) + 0.25
            Vx = V3*(1-exp(-(val)^5))

            # Slight drop during transition
            val = (1/0.8) * (t-t1) / (t2-t1)
            Vz = 0.5 * (5 * val^4 * exp(-val^5))
            Vz = 0.2*V3 * Vz

            return [-Vx, 0, -Vz]

        # ------------ CRUISE --------------------------------------------------
        elseif t&lt;t3

            return [-V3, 0, 0]

        # ------------ TRANSITION ----------------------------------------------
        elseif t&lt;t4

            # Weibull decceleration to hover
            val = 1.5 * (1 - (t-t3) / (t4-t3))
            Vx = V3*(1-exp(-(val)^5))

            # Slight climb during transition
            val = 2.0 * (t-t3) / (t4-t3)
            Vz = 0.5 * (5 * val^4 * exp(-val^5))
            Vz = 0.2*V3 * Vz

            return [-Vx, 0, Vz]

        # ------------ LANDING -------------------------------------------------
        else

            # Weibull acceleration to target descend
            if (t-t4)&lt;(1-t4)*0.35
                val = (t-t4) / ((1-t4)*0.35)
                Vz = V5*(1-exp(-(2*val)^5))
            # Weibull decceleration to hover
            else
                val = 1 - ((t-t4) - (1-t4)*0.35) / ((1-t4)*(1-0.35))
                Vz = V0 + V5*(1-exp(-(2*val)^10))
            end

            return [0, 0, -Vz]

        end
    end</code></pre><h5 id="Define-Vehicle-Angle-function"><a class="docs-heading-anchor" href="#Define-Vehicle-Angle-function">Define Vehicle Angle function</a><a id="Define-Vehicle-Angle-function-1"></a><a class="docs-heading-anchor-permalink" href="#Define-Vehicle-Angle-function" title="Permalink"></a></h5><pre><code class="language-julia"> &quot;&quot;&quot;
        Receives a nondimensional time between 0 and 1, and returns the angle
        (in degrees) of the aircraft.
        Returns: (angle_aircraft)
    &quot;&quot;&quot;
    function angleaircraft(t)

        # ------------ TAKE OFF ------------------------------------------------
        if t&lt;t1
            return [0, 0, 0]

        # ------------ TRANSITION ----------------------------------------------
        elseif t&lt;t2
            val = 1.5 * (t-t1) / (t2-t1)
            val3 = 1.5*val
            val3 = (val3)^(val3 &lt; 1 ? 3 : 1.5)
            angle_aircraft = -15*(1.5/0.75 * val3^0.5 * exp(-(val3^1.5)))
            return [0, angle_aircraft,0 ]

        # ------------ CRUISE --------------------------------------------------
        elseif t&lt;t3
            return [0, 0, 0]

        # ------------ TRANSITION ----------------------------------------------
        elseif t&lt;t4
            # Weibull decceleration to hover
            val = 1.5 * (1 - (t-t3) / (t4-t3))
            # Slight climb during transition
            val = 2.0 * (t-t3) / (t4-t3)
            angle_aircraft = 15 * 0.5 * (5 * val^4 * exp(-val^5))
            return [0, angle_aircraft, 0]

        # ------------ LANDING -------------------------------------------------
        else
            return [0, 0, 0]
        end
    end
</code></pre><h5 id="Define-a-Maneuver"><a class="docs-heading-anchor" href="#Define-a-Maneuver">Define a Maneuver</a><a id="Define-a-Maneuver-1"></a><a class="docs-heading-anchor-permalink" href="#Define-a-Maneuver" title="Permalink"></a></h5><p>The maneuver is an object that returns the angle of tilting surfaces, RPM of rotor sets, translational velocity and angle of the vehicle. Each of these attributes must be defined as a function of non-dimensional time. Every vehicle attribute must be accounted for, even if a blank function is placed in the object. </p><pre><code class="language-julia">    angle = (angle_main, angle_tandem)
    if add_rotors
        RPM = (RPM_main, RPM_tandem)
    else
        RPM = ()
    end
    Vvehicle = Vaircraft
    anglevehicle = angleaircraft

    maneuver = uns.KinematicManeuver(angle, RPM, Vvehicle, anglevehicle)</code></pre><div class="admonition is-warning"><header class="admonition-header">Note</header><div class="admonition-body"></div></div><pre><code class="language-none">    The simulator modifies the velocity and angle of the vehicle by using the derivative velocity and angle functions respectively. The angle, RPM, tilt angle, and velocity functions do not directly define the current motion. This also means that the derivative of each of these functions must be defined (The plot of each function must be continuous.).</code></pre><h5 id="Define-initial-velocity"><a class="docs-heading-anchor" href="#Define-initial-velocity">Define initial velocity</a><a id="Define-initial-velocity-1"></a><a class="docs-heading-anchor-permalink" href="#Define-initial-velocity" title="Permalink"></a></h5><p>The initial state of the vehicle must be defined. </p><pre><code class="language-julia">    Vinit = Vref*maneuver.Vvehicle(0)       # (m/s) initial vehicle velocity
                                            # (rad/s) initial vehicle angular velocity
    Winit = pi/180 * (maneuver.anglevehicle(0+1e-12)-
                                          maneuver.anglevehicle(0))/(ttot*1e-12)</code></pre><div class="admonition is-success"><header class="admonition-header">Note</header><div class="admonition-body"></div></div><pre><code class="language-none">The initial position, tilt-angle and vehicle angle is defined when defining the geometry.  </code></pre><h2 id="Simulate"><a class="docs-heading-anchor" href="#Simulate">Simulate</a><a id="Simulate-1"></a><a class="docs-heading-anchor-permalink" href="#Simulate" title="Permalink"></a></h2><h5 id="Generate-a-Simulation-object"><a class="docs-heading-anchor" href="#Generate-a-Simulation-object">Generate a Simulation object</a><a id="Generate-a-Simulation-object-1"></a><a class="docs-heading-anchor-permalink" href="#Generate-a-Simulation-object" title="Permalink"></a></h5><pre><code class="language-julia">    simulation = uns.Simulation(vehicle, maneuver, Vref, RPMref, ttot;
                                                    Vinit=Vinit, Winit=Winit)</code></pre><h5 id="Simulate-or-visualize"><a class="docs-heading-anchor" href="#Simulate-or-visualize">Simulate or visualize</a><a id="Simulate-or-visualize-1"></a><a class="docs-heading-anchor-permalink" href="#Simulate-or-visualize" title="Permalink"></a></h5><pre><code class="language-julia">    # ----------------- SIMULATION MONITOR -------------------------------------
    monitor = generate_monitor_vahana(vehicle, rho, RPMref, nsteps, save_path, Vinf)

    # ----------------- RUN SIMULATION -----------------------------------------
    pfield = uns.run_simulation(simulation, nsteps;
                                      # OUTPUT OPTIONS
                                      save_path=save_path,
                                      run_name=run_name,
                                      prompt=prompt,
                                      verbose=verbose, v_lvl=v_lvl,
                                      save_code=splitdir(@__FILE__)[1]
                                      )</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../define-a-rotor/">« How to Define a Custom Rotor</a><a class="docs-footer-nextpage" href="../set-up-runtime-functions/">How to Set up Run-time Functions »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 9 July 2020 17:11">Thursday 9 July 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
