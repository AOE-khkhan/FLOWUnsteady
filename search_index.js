var documenterSearchIndex = {"docs":
[{"location":"tutorials/first-steps/#First-Steps","page":"First Steps","title":"First Steps","text":"","category":"section"},{"location":"tutorials/first-steps/#Geometry-Basics","page":"First Steps","title":"Geometry Basics","text":"","category":"section"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"In this tutorial, we'll begin by defining the geometry for a simple wing.  Note that all the functions used are described in the Reference section of this documentation if you would like further information at any point.  Before you begin this tutorial, it is expected that you've already installed the necessary components of FLOWUnsteady, and that you are familiar with visualization in Paraview.","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"First things first, we need to include the FLOWUnsteady components","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"import FLOWUnsteady\nuns = FLOWUnsteady\nvlm = uns.vlm\n\nspan = 1.0              #wing span\naspectratio = 10.0      #wing aspect ratio\ntaperratio = 0.5        #wing taper ratio\nwingtwist = 0.0         #wing twist\nwingsweep = 10.0        #wing sweep in degrees\nwingdihedral = 7.0      #wing dihedral in degrees","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"import FLOWUnsteady\nuns = FLOWUnsteady\nvlm = uns.vlm","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"Let's begin with a single section, symmetric wing.  We'll start by defining some basic geometry.","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"span = 1.0              #wing span\naspectratio = 10.0      #wing aspect ratio\ntaperratio = 0.5        #wing taper ratio\nwingtwist = 0.0         #wing twist\nwingsweep = 10.0        #wing sweep in degrees\nwingdihedral = 7.0      #wing dihedral in degrees","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"Then we'll call the simpleWing() function to create a simple wing object.","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"mainwing = vlm.simpleWing(span,aspectratio,taperratio,wingtwist,wingsweep,wingdihedral)","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"Congratulations! You've created your first wing object.","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"info: Exploring wing objects\nIf you want, you can take a moment to explore the contents of your newly created mainwing.  You can do so using fieldnames(mainwing) and poking around. The Reference section will have more info on the contents of the wing object.","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"Next, let's create a wing system.","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"system = vlm.WingSystem()","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"You now have an empty wing system, so let's add our mainwing object to it with the name \"mainwing.\"","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"vlm.addwing(system,\"mainwing\",mainwing)","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"Now that we have a wing system, let's save it as a .vtk file so we can view it in paraview.  In order to do so, we are required to define a freestream velocity.","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"Vinf(x,t) = [1,0,0]         #non-dimensional function defining free stream velocity\nvlm.setVinf(system, Vinf)   #set freestream velocity for the system","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"We will also want to set some parameters for saving files and set up our file system to put the files where we want.","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"danger: Be careful with rm\nMake sure you have set your save_path to something non-important so the rm command doesn't delete anything you'll miss.","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"run_name = \"tutorial\"           #define identifier at beginning of file names\nsave_path = \"./simplewing/\"     #define directory where files will be saved\n\nrun(`rm -rf $save_path`)        #clear out directory where files will be saved\nrun(`mkdir $save_path`)         #re-create directory fresh","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"Finally, we can save the files.","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"vlm.save(system, run_name; path=save_path)  #save geometry in a .vtk file format","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"And now we can view our wing in Paraview using the command run(`paraview --data=\"$(save_path)/$(run_name)_mainwing_vlm.vtk\"`) (assuming you've set up an alias for paraview on your computer).","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"(Image: basic wing)","category":"page"},{"location":"tutorials/first-steps/#Adding-a-Rotor","page":"First Steps","title":"Adding a Rotor","text":"","category":"section"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"Now that we have a basic wing, let's go ahead and add a rotor.  We'll use some data for the rotor that already exists in FLOWUnsteady.  You can visit the How-to guides for more information on creating your own rotor database.","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"rotor_file = \"apc10x7.csv\"          # Rotor geometry\ndata_path = uns.def_data_path       # Path to rotor database","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"With the rotor data, we can generate our rotor. This might take a minute or so to run. We supress the output here with a semi-colon as it prints a large output.","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"rotor_file = \"apc10x7.csv\"          # hide\ndata_path = uns.def_data_path       # hide\n\nR, B = uns.read_rotor(rotor_file; data_path=data_path)[[1,3]] #get the radius for later\n\nrotor = uns.generate_rotor(rotor_file; pitch=0.0,\n                                            n=10, CW=true, ReD=1.5e6,\n                                            verbose=true, xfoil=true,\n                                            data_path=data_path,\n                                            plot_disc=false);","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"And then we can generate a rotor object, where we again supress the output.","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"rotors = vlm.Rotor[rotor];","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"This will put the rotor at the default location and orientation which we will define here since we now need to move the rotor relative to the wing which is already at this location.","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"vehicleorigin = [0.0; 0.0; 0.0]\nvehicleaxis = [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0]","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"To move the rotor, we need to define a new origin point.","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"rotororigin = [-0.1; 0.0; 0.0]","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"Then we can use that origin to set the rotor coordinate system in order to move the rotor.","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"for rotor in rotors\n    vlm.setcoordsystem(rotor, rotororigin, vehicleaxis; user=true)\nend","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"which we can put in a tuple that stores our rotor system(s).","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"rotor_systems = (rotors,);","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"We also need to add it to our overall system.","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"for rotor in rotors; vlm.addwing(system, run_name, rotor); end;","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"Like setting the Vinf parameter for the main wing, we need to give our rotor an RPM as well.","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"RPMref = 6000       #reference RPM\nfor rotor in rotors; vlm.setRPM(rotor, RPMref); end;","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"We should now be able to visualize our wing with a rotor.","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"run(`rm -rf $save_path`)\nrun(`mkdir $save_path`)\n\nvlm.save(system, run_name; path=save_path)\nrun(`paraview --data=\"$(save_path)/tutorial_mainwing_vlm.vtk;tutorial_tutorial_Blade1_vlm.vtk;tutorial_tutorial_Blade2_vlm.vtk;tutorial_tutorial_Blade1_loft.vtk;tutorial_tutorial_Blade2_loft.vtk;\"`)","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"(Image: wing with rotor)","category":"page"},{"location":"tutorials/first-steps/#Other-Systems","page":"First Steps","title":"Other Systems","text":"","category":"section"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"In order run an analysis with our little airplane, we're going to have to add a few more systems","category":"page"},{"location":"tutorials/first-steps/#VLM-Systems","page":"First Steps","title":"VLM Systems","text":"","category":"section"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"First let's create a VLM system and add our main wing to it.","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"vlm_system = vlm.WingSystem()\n\nvlm.addwing(vlm_system, \"mainwing\", mainwing)","category":"page"},{"location":"tutorials/first-steps/#Wake-Systems","page":"First Steps","title":"Wake Systems","text":"","category":"section"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"Next, let's create a wake system and add both the VLM system and rotor.","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"wake_system = vlm.WingSystem()\n\nvlm.addwing(wake_system, \"SolveVLM\", vlm_system)\n\nfor rotor in rotors; vlm.addwing(wake_system, run_name, rotor); end;","category":"page"},{"location":"tutorials/first-steps/#Tilting-Systems","page":"First Steps","title":"Tilting Systems","text":"","category":"section"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"We'll also need to identify tilting objects, but since we don't have any tilting components yet, we'll just initialize an empty tuple. For more information on adding tilting objects (like control surfaces, or tilt-wings) see How to Define Vehicle Systems.","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"tilting_systems = ();","category":"page"},{"location":"tutorials/first-steps/#Kinematic-Maneuvers","page":"First Steps","title":"Kinematic Maneuvers","text":"","category":"section"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"Now let's define our maneuver. For now, let's just have the airplane fly in a straight and level. We are going to have to define non-dimensional functions for the velocity for the vehicle, the angle for the vehicle, the angles for our tilting systems, and the rotation rate for the rotor(s).","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"info: Non-dimensionalized Functions\nThe functions that define the kinematic maneuver must be defined non-dimensionally. For more information on this, see How to Define Kinematic Maneuvers.","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"We'll start with the vehicle velocity function.","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"Vvehicle(t) = [-1.0,0.0,0.0]","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"Next, let's define the vehicle angle.","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"anglevehicle(t) = zeros(3)","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"Now the angle of the titling systems (we don't have any, so it's just empty again).","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"angle = ();","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"Lastly, we need to define a rotation rate function for each of the rotors.","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"RPM_fun(t) = 1.0\n\nRPM = (RPM_fun, );","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"With all the individual elements defined, we can create a maneuver","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"maneuver = uns.KinematicManeuver(angle, RPM, Vvehicle, anglevehicle)","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"We can also plot the maneuver to quickly see what we made.","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"uns.plot_maneuver(maneuver)","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"A plot of the maneuver is helpful, but visualizing in Paraview can also be helpful. In order to do that, however, we first need to set up a simulation.","category":"page"},{"location":"tutorials/first-steps/#Setting-up-a-Basic-Simulation","page":"First Steps","title":"Setting up a Basic Simulation","text":"","category":"section"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"We already have most of the elements we need to define a simulation, but need to create a vehicle to be used in the simulation with the systems we've already defined.","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"vehicle = uns.VLMVehicle(   system;\n                            tilting_systems = tilting_systems,\n                            rotor_systems   = rotor_systems,\n                            vlm_system      = vlm_system,\n                            wake_system     = wake_system,\n                        );","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"In addition, we still need to define a reference velocity, the total time for the simulation, and a few initial conditions.","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"Vref = 10.0         #define a reference velocity for the vehicle\nttot = 1.0          #define a total simulation time, in seconds\nnsteps = 300        #define the number of steps the simulation will take\n\n#initial conditions\ntinit = 0.0                                  #initial time\nVinit = Vref*maneuver.Vvehicle(tinit/ttot)   #initial linear velocity\nWinit = zeros(3)                             #initial angular velocity","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"With everything now defined, we can create a simulation","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"simulation = uns.Simulation(vehicle, maneuver, Vref, RPMref, ttot; Vinit=Vinit, Winit=Winit, t=tinit);","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"Finally, we can visualize the maneuver in Paraview.","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"files = uns.visualize_kinematics(   simulation, nsteps, save_path;\n                                    run_name=run_name,\n                                    prompt=false,\n                                    paraview=false\n                                )\n\nrun(`paraview --data=\"$save_path/$files\"`)","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"(Image: moving wing and rotor)","category":"page"},{"location":"tutorials/first-steps/#Running-the-Simulation","page":"First Steps","title":"Running the Simulation","text":"","category":"section"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"We also now run the simulation and use Paraview to look at the outputs.","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"note: Outputs\nWe are only outputting the basic pressure field here. In order to have additional outputs, it is necessary to write some extra runtime functions, see How to Set up Run-time Functions for more information.","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"note: Run Time\nRunning simulations typcially takes a while.  You may want to reduce nsteps, but the visual below shows results for 300 steps.","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"nullfunc(args...) = false\npfield = uns.run_simulation(simulation, nsteps;\n                                    surf_sigma=R/10,\n                                    Vinf=Vinf,\n                                    save_path=save_path,\n                                    run_name=run_name,\n                                    prompt=false,\n                                    verbose=true,\n                                    extra_runtime_function=nullfunc\n                                    )\n\nrun(`paraview --data=\"$save_path/$(files);tutorial_pfield...vtk\"`)","category":"page"},{"location":"tutorials/first-steps/","page":"First Steps","title":"First Steps","text":"(Image: pressure field)","category":"page"},{"location":"reference/FLOWVLMfunctions/#Functions-Contained-in-FLOWVLM","page":"Functions Contained in FLOWVLM","title":"Functions Contained in FLOWVLM","text":"","category":"section"},{"location":"reference/FLOWVLMfunctions/","page":"Functions Contained in FLOWVLM","title":"Functions Contained in FLOWVLM","text":"Modules = [FLOWVLM]\nOrder   = [:function, :type]","category":"page"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.FLOWVLM2OCCBlade-Tuple{Any,Any,Int64,Bool}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.FLOWVLM2OCCBlade","text":"Returns a CCBlade's rotor object corresponding to the i-th blade. The r position used to generate the object are the control points, Rhub is the minimum radius given when initializing the FLOWVLM Rotor object, and Rtip is the maximum. The precone given to CCBlade is 0 since precone it is expected to be already accounted for in the geometry given by the user when initializing the FLOWVLM Rotor.\n\nIt applies 3D corrections to the airfoil polars given for initializing the FLOWVLM Rotor, hence the RPMs for those corrections must be specified.\n\nWARNING: This function will use the Inflow field, hence make sure they are updated.\n\nNOTE: In the current implementation it assumes a constant Reynolds number on each airfoil throughout operation as captured in the polar used for initializing the FLOWVLM Rotor. The implementation of a varying Reynolds will be left for future development as needed.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.OCCB2CCB-Tuple{FLOWVLM.OCCBRotor,Bool,FLOWVLM.OCCBInflow}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.OCCB2CCB","text":"Convert a rotor object from the old-CCBlade format to the new CCBlade type.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.Vind-Tuple{Any,Any}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.Vind","text":"Returns the velocity induced at point X\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM._addsolution-Tuple{FLOWVLM.Rotor,Vararg{Any,N} where N}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM._addsolution","text":"Extension of WingSystem's _addsolution() function\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM._aveVinf-Tuple{Any}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM._aveVinf","text":"Returns the average Vinf from all control points\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM._calc_airfoils-Tuple{FLOWVLM.Rotor,Int64,Float64,Any,Any}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM._calc_airfoils","text":"Calculates the airfoils at each control point\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM._calc_distributedloads_lookuptable-Tuple{FLOWVLM.OCCBRotor,FLOWVLM.OCCBInflow,Bool}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM._calc_distributedloads_lookuptable","text":"Calculates the load distribution by using the airfoil lookup table on the given inflow (this assumes that the inflow already includes all induced velocity and it is the effective inflow).\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM._calc_inflow-Tuple{FLOWVLM.Wing,Any,Float64}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM._calc_inflow","text":"Returns the inflow velocity at the requested target point on all horseshoes, where the inflow is calculated as freestream + rotational velocity.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM._calculate_areas-Tuple{Any}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM._calculate_areas","text":"Calculates the area of each panel\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM._calculate_forces-Tuple{Any,Float64}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM._calculate_forces","text":"Aerodynamic force calculated through Kutta-Joukowski theorem. Give it per_unit_span=true to calculate the force per unit length of span. If lifting_interac==false, the force doesn't include the induced velocity, hence, no interaction between lifting surfaces is calculated and induced drag will be zero, but it is an efficient way of calculating the lift of an individual lifting surface\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM._calculate_moments-Tuple{Any,Any}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM._calculate_moments","text":"Calculates total moment and decomposition into roll, pitch, and yaw\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM._ccblade2global-Tuple{FLOWVLM.Wing,Array{Float64,1},Bool}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM._ccblade2global","text":"Receives a vector in CCBlade's coordinate system relative to blade and transforms it into the global coordinate system. NOTE: This function only rotates V into the new axis without translating it unless otherwise indicated.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM._ccbladeOaxis-Tuple{FLOWVLM.Wing,Bool}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM._ccbladeOaxis","text":"Returns the CCBlade's transformation matrix relative to the blade's c.s.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM._check-Tuple{FLOWVLM.Rotor}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM._check","text":"Checks for consistency in internal variables\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM._counter_interpret-Tuple{Array{Float64,1},Array{Float64,2},Array{Float64,1},Array{Float64,2}}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM._counter_interpret","text":"For a coordinate system 'inception2' that is incapsulated inside another coordinate system 'inception1', it receives its interpretation in the global coordinate system and counterinterprets it back to the 'inception1' system.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM._decompose-Tuple{Any,Any}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM._decompose","text":"Decomposes a force field into sideslip, drag, and lift components\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM._fetch_wing-Tuple{FLOWVLM.Rotor,Vararg{Any,N} where N}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM._fetch_wing","text":"Extension of WingSystem's _fetch_wing() function\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM._fetch_wing-Tuple{FLOWVLM.WingSystem,Int64}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM._fetch_wing","text":"Given a panel index in the system, it returns the wing the panel belongs to and that wing's index of the panel\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM._generate_blade-Tuple{FLOWVLM.Rotor,Int64}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM._generate_blade","text":"Generates the blade and discretizes it into lattices\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM._get_O-Tuple{FLOWVLM.Rotor}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM._get_O","text":"Extension of WingSystem's _get_O() function\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM._get_Oaxis-Tuple{FLOWVLM.Rotor}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM._get_Oaxis","text":"Extension of WingSystem's _get_O() function\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM._global2ccblade-Tuple{FLOWVLM.Wing,Array{Float64,1},Bool}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM._global2ccblade","text":"Receives a vector in the global coordinate system and transforms it into CCBlade's coordinate system relative to blade. NOTE: This function only rotates V into the new axis without translating it unless otherwise indicated. (for definition of axes see notebook entry 20171202)\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM._interpret-Tuple{Array{Float64,1},Array{Float64,2},Array{Float64,1},Array{Float64,2}}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM._interpret","text":"For a coordinate system 'inception2' that is incapsulated inside another coordinate system 'inception1', it returns its interpretation in the global coordinate system\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM._span_eff-Tuple{Any}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM._span_eff","text":"Returns the span effective of a Wing or WingSystem\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM._verif_discr-NTuple{7,Any}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM._verif_discr","text":"Verifies correct splining for lattice and element discretization\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.addchord-Tuple{FLOWVLM.Wing,Float64,Float64,Float64,Float64,Float64,Int64}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.addchord","text":"addchord(wing, x, y, z, c, twist, n, r=1.0)\n\nAdds a new chord to the wing and creates n lattices in the new section. Wing must be build from left to right.\n\nArguments\n\nx       : x-position leading edge of the chord.\ny       : y-position of the chord.\nz       : z-position leading edge of the chord.\nc       : Chord length.\ntwist   : Twist of the chord in degrees.\nn::Int64: Number of lattices in the new section.\n\nOptional arguments\n\nr       : Ratio between lengths of first and last lattices.\ncentral : Give it true to take the length ratio between the lattice\n          midway and first and last. Give it a number between 0 and 1\n          to define the position of the reference midway.\nrefinement : Use this option for more complex refinements. It\n          receives an array `[sec1, sec2, ...]` with sections of\n          refinements in the format `sec=[c, n, r]`, with `c` the length\n          of this section (sum of all c = 1), `n` the ratio of lattices\n          in this section, and `r` the increment ratio. If this option\n          is used, it will ignore arguments `r` and `central`.\n\nExamples\n\n`julia> wing = Wing(0.0, 0.0, 0.0, 10.0, 3.0);`\n`julia> addchord(wing, 2.5, 10.0, 5.0, 5.0, 0.0, 10);`\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.addwing-Tuple{FLOWVLM.Rotor,String,Any}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.addwing","text":"Extension of WingSystem's addwing() function\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.addwing-Tuple{FLOWVLM.WingSystem,String,Any}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.addwing","text":"addwing(self::WingSystem, wing_name::String, wing::Wing) Adds a wing to the system with the position and orientation of local reference being interpreted in relation to the local reference frame of the system.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.axis_rotation-Tuple{Any,Any}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.axis_rotation","text":"returns the transformation matrix of rotation around an arbitrary axis of unit vector r\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.calc_aerodynamicforces-Tuple{FLOWVLM.Rotor,Float64}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.calc_aerodynamicforces","text":"Calculates sectional aerodynamic forces in a rotor where the field DistributedLoad has already been solved for. It also calculates the bound circulation Gamma\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.calc_distributedloads-Tuple{FLOWVLM.Rotor,Any,Any,Float64}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.calc_distributedloads","text":"Calculates the distributed loads from CCBlade. It also stores normal (Np) and tangential (Tp) components relative to the plane of rotation as given by CCBlade, if include_comps==true.\n\nIf return_performance==true, it returns propulsive efficiency eta, thrust coefficient CT, and torque coefficient CQ of each blade.\n\nNOTE: These loads are per unit length of span\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.calc_inflow-Tuple{FLOWVLM.Rotor,Any,Any}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.calc_inflow","text":"Receives the freestream velocity function V(x,t) and the current RPM of the rotor, and it calculates the inflow velocity field that each control point sees in the global coordinate system\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.calc_thrust_torque-Tuple{FLOWVLM.Rotor}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.calc_thrust_torque","text":"calc_thrust_torque(rotor)\n\nIntegrates the load distribution along every blade to return the thrust and torque of the rotor.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.calc_thrust_torque_coeffs-Tuple{FLOWVLM.Rotor,Real}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.calc_thrust_torque_coeffs","text":"calc_thrust_torque_coeffs(rotor, rho, t)\n\nIntegrates the load distribution along every blade to return the thrust and torque coefficients of the rotor. Thrust coefficient CT calculated as CT=\frac{T}{ ho n^2 D^4}, torque coefficient CQ calculated as CQ=\frac{Q}{ ho n^2 D^5}\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.calculate_field-Tuple{Any,String}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.calculate_field","text":"calculate_field(wing, field_name [, qinf, S, l, r_cg]) Calculates the field field_name on a Wing or WingSystem. See FIELDS for a list of implemented fields.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.calculate_force_trefftz-Tuple{Any,Array{Float64,1},Float64}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.calculate_force_trefftz","text":"Calculates the force induced by the wake sheet assuming it planar in the direction of Vinf. This method works well only for an isolated lifting surface and should not be used on interacting lifting surfaces.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.check_coord_sys-Tuple{Array{Float64,2}}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.check_coord_sys","text":"Checks that the unit vectors given as the matrix M=[i;j;k] define a coordinate system\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.complexWing-Tuple{Float64,Float64,Int64,Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,1}}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.complexWing","text":"`complexWing(b::Float64, AR::Float64, tr::Float64, n::Int64,\n                    pos::Array{Float64,1}, twist::Array{Float64,1},\n                    sweep::Array{Float64,1}, dihed::Array{Float64,1};\n                    symmetric::Bool=true)`\n\nReturns a Wing object made of multiple sections with the specified dimensions.\n\nArguments\n\nb::Float64          : Span.\nAR::Float64         : Aspect ratio (span over tip chord).\nn::Int64            : Number of lattices in semi-span.\npos::Array{Float64,1}   : Position of each chord along semi-span.\nclen::Array{Float64,1}  : Length of each chord as a fraction of tip chord.\ntwist::Array{Float64,1} : (deg) twist of each chord.\nsweep::Array{Float64,1} : (deg) sweep of each section.\ndihed::Array{Float64,1} : (deg) dihedral of each section.\n\nOptional Arguments\n\nsymmetric::Bool=true    : If false, returns only the semi-span.\nchordalign::Float64=0.0 : Indicate position along chord length to align                               chords. Give it 0 for alignment about leading                               edge, 0.25 for alignment about quarter chord,                               and 1.0 for alignment about trailing edge.\n\nExample\n\n  # Wing Parameters\n  b = 1.0                     # (m) span\n  AR = 12.0                   # Span over tip chord\n  n = 50                      # Lattices in semi-span\n\n  # Chords\n  pos = Float64[0, 0.25, 0.75, 1]  # Position of each chord along semi-span\n  clen = Float64[2, 1.5, 1.5, 1]   # Length of each chord\n  twist = Float64[0, 0, -2, -4]    # (deg) twist at each chord\n  sweep = Float64[10, 15, 35]      # (deg) sweep of each section\n  dihed = Float64[2, 5, 7.5]       # (deg) dihedral of each section\n\n  # Generates the wing\n  wing = vlm.complexWing(b, AR, n, pos, clen, twist, sweep, dihed)\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.copy-Tuple{FLOWVLM.Wing}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.copy","text":"Returns a deep copy of this wing\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.countertransform-Tuple{Array{Float64,1},Array{Float64,2},Array{Float64,1}}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.countertransform","text":"Rotates and translates back a vector V' that had been rotated and translated into the system (i', j', k') with origin T, and returns the original V. To ease repetitive computation, instead of giving the unit vectors, give the inverse of their matrix.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.ellipticWing-Tuple{Float64,Float64,Float64}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.ellipticWing","text":"Returns a wing of elliptic load distribution (no sweep, no dihedral, no tapper). Give it elliptic=\"twist\" to get an elliptic twist distribution, otherwise it will build an elliptic chord distribution.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.exampleWing-Tuple{}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.exampleWing","text":"Example of a system of lifting surfaces (WingSystem)\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.fields_summary-Tuple{Any}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.fields_summary","text":"Returns a dictionary summarizing key parameters on a Wing or WingSystem\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.getControlPoint-Tuple{FLOWVLM.Rotor,Int64}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.getControlPoint","text":"Returns the m-th control point of the system\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.getControlPoint-Tuple{FLOWVLM.Wing,Int64}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.getControlPoint","text":"Returns the m-th control point\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.getControlPoint-Tuple{FLOWVLM.WingSystem,Int64}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.getControlPoint","text":"Returns the m-th control point of the system\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.getHorseshoe-Tuple{FLOWVLM.Rotor,Int64}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.getHorseshoe","text":"Returns the m-th horseshoe of the system in the global coordinate system\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.getHorseshoe-Tuple{FLOWVLM.Wing,Int64}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.getHorseshoe","text":"Returns the m-th horseshoe in the global coordinate system\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.getHorseshoe-Tuple{FLOWVLM.WingSystem,Int64}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.getHorseshoe","text":"Returns the m-th horseshoe of the system in the global coordinate system\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.getHorseshoes-Tuple{Any}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.getHorseshoes","text":"Returns all the horseshoes of the Wing or WingSystem\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.getLE-Tuple{FLOWVLM.Wing,Int64}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.getLE","text":"Returns leading-edge coordinates of the n-th chord\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.getTE-Tuple{FLOWVLM.Wing,Int64}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.getTE","text":"Returns trailing-edge coordinates of the n-th chord\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.getVinfs-Tuple{FLOWVLM.Rotor}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.getVinfs","text":"Returns the undisturbed freestream at each control point\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.getVinfs-Tuple{FLOWVLM.WingSystem}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.getVinfs","text":"Returns the undisturbed freestream at each control point, or at the horseshoe point indicated as target.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.getVinfs-Tuple{FLOWVLM.Wing}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.getVinfs","text":"Returns the undisturbed freestream at each control point, or at the horseshoe point indicated as target.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.get_A-Tuple{Any,Int64}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.get_A","text":"Returns the area of the m-th panel, with self either Wing or WingSystem. For derivation, see notebook entry 20170619.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.get_CG-Tuple{Any}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.get_CG","text":"Returns the center of gravity of the wing, with self either Wing or WingSystem.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.get_barc-Tuple{Any}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.get_barc","text":"Returns the mean chord length of a Wing or WingSystem\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.get_blade-Tuple{FLOWVLM.Rotor,Int64}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.get_blade","text":"Returns the requested blade\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.get_m-Tuple{FLOWVLM.Rotor}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.get_m","text":"Returns total number of lattices in the rotor\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.get_m-Tuple{FLOWVLM.WingSystem}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.get_m","text":"Returns total number of lattices in the wing\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.get_m-Tuple{FLOWVLM.Wing}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.get_m","text":"Returns total number of lattices in the wing\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.get_mBlade-Tuple{FLOWVLM.Rotor}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.get_mBlade","text":"Returns total number of lattices on each blade\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.get_r-Tuple{Any,Int64}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.get_r","text":"Returns the center of gravity of the m-th panel, with self either Wing or WingSystem.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.get_wing-Tuple{FLOWVLM.Rotor,Vararg{Any,N} where N}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.get_wing","text":"Extension of WingSystem's get_wing() function\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.get_wing-Tuple{FLOWVLM.WingSystem,Int64}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.get_wing","text":"Returns the i-th wing in the system\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.get_wing-Tuple{FLOWVLM.WingSystem,String}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.get_wing","text":"Returns the wing in the system under the requested name\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.get_wings-Tuple{FLOWVLM.WingSystem}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.get_wings","text":"Returns the wings in the system as a dictionary Dict(wing_name => Wing)\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.grid_dependance-Tuple{Any,Any}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.grid_dependance","text":"Receives a function generate_wing(n) and plots aerodynamic characteristics at different lattice resolutions\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.initialize-Tuple{FLOWVLM.Rotor,Int64}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.initialize","text":"Initializes the geometry of the rotor, discretizing each blade into n lattices\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.occb_af_from_data-Tuple{Any,Any,Any}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.occb_af_from_data","text":"af_from_data(alpha, cl, cd)\n\nCreate an AirfoilData object directly from alpha, cl, and cd arrays.\n\naffromaerodynfile calls this function indirectly.  Uses a cubic B-spline (if the order of the data permits it).  A small amount of smoothing of lift and drag coefficients is also applied to aid performance for gradient-based optimization.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.occb_airfoil-Tuple{FLOWVLM.OCCBAirfoilData,Real}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.occb_airfoil","text":"private\n\nevalute airfoil spline at alpha\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.planform_area-Tuple{Any}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.planform_area","text":"Receives a Wing or WingsSystem and return the planform area, which is the area of the projection on the xy-plane of its local coordinate system.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.rotate-Tuple{FLOWVLM.Rotor,Float64}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.rotate","text":"Rotates the rotor degs degrees in the direction of rotation\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.save-Tuple{FLOWVLM.Rotor,String}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.save","text":"Saves the rotor in VTK legacy format\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.save-Tuple{FLOWVLM.Wing,String}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.save","text":"Saves the wing domain in VTK legacy format\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.save_loft-Tuple{FLOWVLM.Rotor,String}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.save_loft","text":"Saves the lofted surface of the blade\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.setRPM-Tuple{FLOWVLM.Rotor,Any}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.setRPM","text":"Sets RPM as the revolutions per minutes of this rotor\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.setVinf-Tuple{FLOWVLM.Rotor,Any}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.setVinf","text":"Sets Vinf(X,t) as the incoming freestream of this rotor\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.setVinf-Tuple{FLOWVLM.Wing,Any}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.setVinf","text":"Sets Vinf(X,t) as the freestream of this wing\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.setVinf-Tuple{FLOWVLM.WingSystem,Any}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.setVinf","text":"Sets Vinf(X,t) as the freestream of all wings in the system\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.setcoordsystem-Tuple{FLOWVLM.Rotor,Array{Float64,1},Array{Float64,2}}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.setcoordsystem","text":"Sets a coordinate system for the rotor. If the user is calling this function, give user=true, otherwise it won't do the automatic translation to blade c.s.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.setcoordsystem-Tuple{FLOWVLM.Wing,Array{Float64,1},Array{Float64,2}}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.setcoordsystem","text":"setcoordsystem(self, O, Oaxis; check=true)\n\nRedefines the local coordinate system of the wing, where O is the new origin and Oaxis is the matrix [i; j; k] of unit vectors\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.setcoordsystem-Tuple{FLOWVLM.WingSystem,Array{Float64,1},Array{Float64,2}}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.setcoordsystem","text":"setcoordsystem(self, O, Oaxis; check=true, wings=String[]) Redefines the local coordinate system of the system, where O is the new origin and Oaxis is the matrix [i; j; k] of unit vectors. It transforms the coordinates of all the wings in the system accordingly.\n\nTo change the local coordinate system of a specific wing relative to the system's coordinate system, give the name of the wing in an array under argument wings.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.simpleWing-NTuple{6,Float64}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.simpleWing","text":"`simpleWing(b, ar, tr, twist, lambda, gamma; twist_tip=twist, n=20, r=2.0)`\n\nGenerates a single-section wing.\n\nArguments\n\nb       :   (float) span.\nar      :   (float) aspect ratio defined as the span over the tip's chord.\ntr      :   (float) taper ratio (tip chord / root chord).\ntwist   :   (float) twist of the root in degrees.\nlambda  :   (float) sweep in degrees.\ngamma   :   (float) dihedral in degrees.\n(OPTIONALS)\ntwist_tip : (float) twist of the tip if different than root.\nn       :   (int)   number of horseshoes per side of the wing.\nr       :   (float) horseshoes' expansion ratio\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.solve-Tuple{Any,Any}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.solve","text":"Solves the VLM of the Wing or WingSystem\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.solvefromCCBlade-Tuple{FLOWVLM.Rotor,Any,Any,Float64}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.solvefromCCBlade","text":"Solves for the Gamma field (circulation) on each blade using CCBlade. It also includes the fields Ftot, L, D, and S. (WARNING: These Ftot, L, D, and S are forces per unit length!)\n\nIf include_comps==true it stores CCBlade-calculated normal and tangential forces in the Rotor.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.solvefromV-Union{Tuple{T}, Tuple{FLOWVLM.Rotor,Array{Array{T,1},1},Vararg{Any,N} where N}} where T<:Array{Float64,1}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.solvefromV","text":"Given the velocity induced at each control point (Vind = Vliftsurface+Vwake), solves for the Gamma field (circulation) on each blade by looking at the airfoil polar at the effective angle of attack of every section. It also includes the fields Ftot, L, D, and S. (WARNING: These Ftot, L, D, and S are forces per unit length!)\n\nTHIS METHOD IS UNSTABLE.\n\nNOTE: Vind is expected to be in the global coordinate system. NOTE: Vind is expected to be formated as Vind[i][j] being the velocity vector of the j-th control point in the i-th blade.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.solvefromVite-Union{Tuple{T}, Tuple{FLOWVLM.Rotor,Array{Array{T,1},1},Vararg{Any,N} where N}} where T<:Array{Float64,1}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.solvefromVite","text":"Given the velocity induced at each control point (Vind = Vwake, no lifting surface), solves for the Gamma field (circulation) on each blade by looking at the airfoil polar at the effective angle of attack of every section. It also includes the fields Ftot, L, D, and S. (WARNING: These Ftot, L, D, and S are forces per unit length!)\n\nThis method solves iteratively until the circulation distribution converges.\n\nNOTE: Vind is expected to be in the global coordinate system. NOTE: Vind is expected to be formated as Vind[i][j] being the velocity vector of the j-th control point in the i-th blade.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.transform-Tuple{Array{Float64,1},Array{Float64,2},Array{Float64,1}}","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.transform","text":"Rotates and translates the vector V.\n\nReceives the i', j', k' unit vectors of an euclidean system with origin T, and returns V'. (In this version, the unit vectors have been organized as a matrix M)\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.OCCBRotor","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.OCCBRotor","text":"Rotor(r, chord, theta, af, Rhub, Rtip, B, precone)\n\nDefine rotor geometry.\n\nArguments\n\nr::Array{Float64, 1}: radial locations (m)\nchord::Array{Float64, 1}: chord lengths (m)\ntheta::Array{Float64, 1}: total twist including pitch (rad)\naf::Array{AirfoilData, 1}: airfoils\nRhub::Float64: hub radius (along blade length)\nRtip::Float64: tip radius (along blade length)\nB::Int64: number of blades\nprecone::Float64: precone angle (rad)\n\n\n\n\n\n","category":"type"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.Rotor","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.Rotor","text":"Rotor(CW, r, chord, theta, LE_x, LE_z, B, airfoil)\n\nObject defining the geometry of a rotor/propeller/wind turbine. This class behaves as an extension of the WingSystem class, hence all functions of WingSystem can be applied to a Rotor object.\n\nArguments\n\nCW::Bool                   : True for clockwise rotation, false for CCW.\nr::Array{Float64,1}        : Radius position for the following variables.\nchord::Array{Float64,1}    : Chord length.\ntheta::Array{Float64,1}    : Angle of attack (deg) from the rotor's plane                               of rotation.\nLE_x::Array{Float64,1}     : x-position of leading edge (positive is ahead                               of radial axis relative to rotation).\nLE_z::Array{Float64,1}     : z-position of leading edge (height from plane                               of rotation).\nB::Int64                   : Number of blades.\n\nOptional Arguments\n\nairfoils::Array{Tuple{Float64, airfoilprep.Polar},1} : 2D airfoil properties                               along blade in the form [ (ri, Polari) ]                               with Polari describes the airfoil at i-th                               radial position ri (both the airfoil geometry                               in Polari and ri must be normalized). At                               least root (r=0) and tip (r=1) must be given                               so all positions in between can be                               extrapolated. This properties are only used                               when calling CCBlade and for generating good                               loking visuals; ignore if only solving the VLM.\n\nNOTE: r here is the radial position after precone is included in the geometry, hence the need of explicitely declaring LE_z.\n\nPROPERTIES\n\nsol : Contains solution fields specific for Rotor types. They are formated         as sol[fieldname] = Dict(                         \"fieldname\" => outputfieldname,                         \"fieldtype\" => \"scalar\" or \"vector\",                         \"fielddata\" => data                         )         where data is an array data[i] = [val1, val2, ...] containing         this field values (scalar or vector) of all control points in the         i-th blade.\n\n<!– NOTE TO SELF: r is the y-direction on a wing, hence, remember to build the                blade from root in the direction of positive y. –>\n\n\n\n\n\n","category":"type"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.Wing","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.Wing","text":"Wing(leftxl, lefty, leftz, leftchord, leftchordtwist)\n\nWing constructor that automatically discretizes the surface into lattices. The wing must we built from left to right. Chords are parallel to the zx-plane, leading edge in the direction of the -xaxis and trailing in the direction of the +xaxis (hence, the span is aligned with the y-axis).\n\n<!– The i-th control point is located at (xm[i], _ym[i]), with left bound –> <!– vortex (xn[i], yn[i]) and right bound vortex (xn[i+1], _yn[i+1]) –>\n\nArguments\n\nleftxl         : x-position of leading edge of the left tip.\nlefty          : y-position of left tip.\n`leftzl          : z-position of leading edge of the left tip.\nleftchord      : Chord of the left tip.\nleftchordtwist : Twist left tip's chord in degrees.\n\nExample\n\njulia julia> wing = Wing(0.0, 0.0, 0.0, 10.0, 3.0);\n\n\n\n\n\n","category":"type"},{"location":"reference/FLOWVLMfunctions/#FLOWVLM.WingSystem","page":"Functions Contained in FLOWVLM","title":"FLOWVLM.WingSystem","text":"WingSystem() Initiates a system of wings. All method applicable to a Wing object are applicable to a WingSystem. When solved, it will calculate the interaction between wings.\n\n\n\n\n\n","category":"type"},{"location":"how-to-guide/paraview-visualization/#Visualize-with-Paraview","page":"Visualize with Paraview","title":"Visualize with Paraview","text":"","category":"section"},{"location":"how-to-guide/define-kinematic-maneuvers/#How-to-Define-Kinematic-Maneuvers","page":"How to Define Kinematic Maneuvers","title":"How to Define Kinematic Maneuvers","text":"","category":"section"},{"location":"how-to-guide/define-kinematic-maneuvers/","page":"How to Define Kinematic Maneuvers","title":"How to Define Kinematic Maneuvers","text":"There are two ways to generate a maneuver in FLOWUnsteady, prescribing a kinematic maneuver and prescribing actions to generate motion. Prescribing a kinematic maneuver, you inform the simulator where the aircraft is moving and the simulator determines the effects. When you prescribe an action, like running the rotors, to the simulator, the simulator then determines the forces on the aircraft that generate motion.","category":"page"},{"location":"how-to-guide/define-kinematic-maneuvers/#Prescribe-a-Kinematic-Maneuver","page":"How to Define Kinematic Maneuvers","title":"Prescribe a Kinematic Maneuver","text":"","category":"section"},{"location":"how-to-guide/define-kinematic-maneuvers/","page":"How to Define Kinematic Maneuvers","title":"How to Define Kinematic Maneuvers","text":"To prescribe a kinematic maneuver you must generate a maneuver object, setup the simulation, and then simulate. Here we use the kinematic maneuver from the Vahana example to further explain. ","category":"page"},{"location":"how-to-guide/define-kinematic-maneuvers/#Generate-a-Maneuver-Object","page":"How to Define Kinematic Maneuvers","title":"Generate a Maneuver Object","text":"","category":"section"},{"location":"how-to-guide/define-kinematic-maneuvers/#Generate-Geometry","page":"How to Define Kinematic Maneuvers","title":"Generate Geometry","text":"","category":"section"},{"location":"how-to-guide/define-kinematic-maneuvers/","page":"How to Define Kinematic Maneuvers","title":"How to Define Kinematic Maneuvers","text":"Before generating a simulation object, you must have generated the geometry object. If you are unsure of how to generate geometry, refer to the tutorial. ","category":"page"},{"location":"how-to-guide/define-kinematic-maneuvers/","page":"How to Define Kinematic Maneuvers","title":"How to Define Kinematic Maneuvers","text":" # Generate geometry\n    (vehicle, grounds) = generate_geometry_vahana(; n_factor=1,\n                                                    xfoil=false,\n                                                    data_path=data_path,\n                                                    run_name=run_name,\n                                                    optargs...)","category":"page"},{"location":"how-to-guide/define-kinematic-maneuvers/#Define-reference-velocity,-RPM,-total-time,-and-number-of-steps","page":"How to Define Kinematic Maneuvers","title":"Define reference velocity, RPM, total time, and number of steps","text":"","category":"section"},{"location":"how-to-guide/define-kinematic-maneuvers/","page":"How to Define Kinematic Maneuvers","title":"How to Define Kinematic Maneuvers","text":"    # Maneuver to perform\n    Vref = 0.25 * 125*0.44704           # Cruise speed\n    RPMref = 100                        # Reference RPM\n    ttot = 30.0                         # Total time to perform maneuver\n    nsteps = 1500                       # Time steps","category":"page"},{"location":"how-to-guide/define-kinematic-maneuvers/#Define-an-Angle-function","page":"How to Define Kinematic Maneuvers","title":"Define an Angle function","text":"","category":"section"},{"location":"how-to-guide/define-kinematic-maneuvers/","page":"How to Define Kinematic Maneuvers","title":"How to Define Kinematic Maneuvers","text":"   \"\"\"\n        Receives a nondimensional time between 0 and 1, and returns the angles\n        (in degrees) of the main wing relative to the aircraft axis.\n    \"\"\"\n    function angle_main(t)\n\n        # ------------ TAKE OFF ------------------------------------------------\n        if t<t1\n            return [0, 90, 0]\n\n        # ------------ TRANSITION ----------------------------------------------\n        elseif t<t2\n            val = 1.5 * (t-t1) / (t2-t1)\n            val1 = val + 0.25\n            angle_main = 90 - 90*(1-exp(-(val1)^5))\n            return [0, angle_main, 0]\n\n        # ------------ CRUISE --------------------------------------------------\n        elseif t<t3\n            return [0, 0, 0]\n\n        # ------------ TRANSITION ----------------------------------------------\n        elseif t<t4\n            # Weibull decceleration to hover\n            val = 1.5 * (1 - (t-t3) / (t4-t3))\n            angle_main = 90 - 90*(1-exp(-(val)^5))\n            return [0, angle_main, 0]\n\n        # ------------ LANDING -------------------------------------------------\n        else\n            return [0, 90, 0]\n        end\n    end","category":"page"},{"location":"how-to-guide/define-kinematic-maneuvers/#Define-RPM-function","page":"How to Define Kinematic Maneuvers","title":"Define RPM function","text":"","category":"section"},{"location":"how-to-guide/define-kinematic-maneuvers/","page":"How to Define Kinematic Maneuvers","title":"How to Define Kinematic Maneuvers","text":"\"\"\"\n        Receives a nondimensional time between 0 and 1, and returns the\n        main wing RPM non-dimensionalized by the hover RPM.\n    \"\"\"\n    function RPM_main(t)\n\n        # ------------ TAKE OFF ------------------------------------------------\n        if t<t1\n            # Weibull acceleration to target climb\n            if t<t1/2\n                val = t / (t1/2)\n                RPM_w = RPM1*(1.05-exp(-(5*val)^2))\n            # Weibull decceleration to hover\n            else\n                val = 1 - (t-t1/2) / (t1/2)\n                RPM_w = 1.0 + (RPM1-1.0)*(1-exp(-(2*val)^5))\n            end\n\n            return RPM_w\n\n        # ------------ TRANSITION ----------------------------------------------\n        elseif t<t2\n            # Increases RPM to sustain forward flight and hover\n            if (t-t1)<(t2-t1)*0.25\n                val = (t-t1)/((t2-t1)*0.25)\n                RPM_w = 1.0 + (RPM2-1.0)*(1-exp(-(2*val)^5))\n            # Decreases RPM as it tilts the wing out of hover support\n            else\n                val = 1 - ((t2-t)/(t2-t1)-0.25) / (1-0.25)\n                RPM_w = RPM2 + (RPM3-RPM2)*(1-exp(-(1.1*val)^5))\n            end\n\n            return RPM_w\n\n        # ------------ CRUISE --------------------------------------------------\n        elseif t<t3\n            RPM_w = RPM3\n            return RPM_w\n\n        # ------------ TRANSITION ----------------------------------------------\n        elseif t<t4\n            # Weibull decceleration to hover\n            val = 1.5 * (1 - (t-t3) / (t4-t3))\n            RPM_w = RPM4 + (RPM3-RPM4)*(1-exp(-(val)^3))\n            return RPM_w\n\n        # ------------ LANDING -------------------------------------------------\n        else\n            # Weibull acceleration to target descend\n            if (t-t4)<(1-t4)*0.55\n                val = (t-t4) / ((1-t4)*0.55)\n                RPM_w = RPM4 + (RPM5-RPM4)*(1-exp(-(3*val)^5))\n            # Weibull decceleration to hover\n            else\n                val = ((t-t4) - (1-t4)*0.55) / ((1-t4)*(1-0.55))\n                val = val + 0.60\n                RPM_w = RPM5*(3.0*(val)^(3.0-1)*exp(-(val)^5.0))/1.0\n            end\n\n            return RPM_w\n\n        end\n    end","category":"page"},{"location":"how-to-guide/define-kinematic-maneuvers/#Define-Vehicle-Velocity-Function","page":"How to Define Kinematic Maneuvers","title":"Define Vehicle Velocity Function","text":"","category":"section"},{"location":"how-to-guide/define-kinematic-maneuvers/","page":"How to Define Kinematic Maneuvers","title":"How to Define Kinematic Maneuvers","text":" \"\"\"\n        Receives a nondimensional time between 0 and 1, and returns the\n        vector of velocity of the aircraft at that instant.\n    \"\"\"\n    function Vaircraft(t)\n\n        # ------------ TAKE OFF ------------------------------------------------\n        if t<t1\n\n            # Weibull acceleration to target climb\n            if t<t1/2\n                val = t / (t1/2)\n                Vz = V0 + V1*(1-exp(-(2*val)^5))\n            # Weibull decceleration to hover\n            else\n                val = 1 - (t-t1/2) / (t1/2)\n                Vz = V1*(1-exp(-(2*val)^5))\n            end\n\n            return [0, 0, Vz]\n\n        # ------------ TRANSITION ----------------------------------------------\n        elseif t<t2\n\n            # Weibull acceleration to cruise\n            val = 1.5 * (t-t1) / (t2-t1) + 0.25\n            Vx = V3*(1-exp(-(val)^5))\n\n            # Slight drop during transition\n            val = (1/0.8) * (t-t1) / (t2-t1)\n            Vz = 0.5 * (5 * val^4 * exp(-val^5))\n            Vz = 0.2*V3 * Vz\n\n            return [-Vx, 0, -Vz]\n\n        # ------------ CRUISE --------------------------------------------------\n        elseif t<t3\n\n            return [-V3, 0, 0]\n\n        # ------------ TRANSITION ----------------------------------------------\n        elseif t<t4\n\n            # Weibull decceleration to hover\n            val = 1.5 * (1 - (t-t3) / (t4-t3))\n            Vx = V3*(1-exp(-(val)^5))\n\n            # Slight climb during transition\n            val = 2.0 * (t-t3) / (t4-t3)\n            Vz = 0.5 * (5 * val^4 * exp(-val^5))\n            Vz = 0.2*V3 * Vz\n\n            return [-Vx, 0, Vz]\n\n        # ------------ LANDING -------------------------------------------------\n        else\n\n            # Weibull acceleration to target descend\n            if (t-t4)<(1-t4)*0.35\n                val = (t-t4) / ((1-t4)*0.35)\n                Vz = V5*(1-exp(-(2*val)^5))\n            # Weibull decceleration to hover\n            else\n                val = 1 - ((t-t4) - (1-t4)*0.35) / ((1-t4)*(1-0.35))\n                Vz = V0 + V5*(1-exp(-(2*val)^10))\n            end\n\n            return [0, 0, -Vz]\n\n        end\n    end","category":"page"},{"location":"how-to-guide/define-kinematic-maneuvers/#Define-Vehicle-Angle-function","page":"How to Define Kinematic Maneuvers","title":"Define Vehicle Angle function","text":"","category":"section"},{"location":"how-to-guide/define-kinematic-maneuvers/","page":"How to Define Kinematic Maneuvers","title":"How to Define Kinematic Maneuvers","text":" \"\"\"\n        Receives a nondimensional time between 0 and 1, and returns the angle\n        (in degrees) of the aircraft.\n        Returns: (angle_aircraft)\n    \"\"\"\n    function angleaircraft(t)\n\n        # ------------ TAKE OFF ------------------------------------------------\n        if t<t1\n            return [0, 0, 0]\n\n        # ------------ TRANSITION ----------------------------------------------\n        elseif t<t2\n            val = 1.5 * (t-t1) / (t2-t1)\n            val3 = 1.5*val\n            val3 = (val3)^(val3 < 1 ? 3 : 1.5)\n            angle_aircraft = -15*(1.5/0.75 * val3^0.5 * exp(-(val3^1.5)))\n            return [0, angle_aircraft,0 ]\n\n        # ------------ CRUISE --------------------------------------------------\n        elseif t<t3\n            return [0, 0, 0]\n\n        # ------------ TRANSITION ----------------------------------------------\n        elseif t<t4\n            # Weibull decceleration to hover\n            val = 1.5 * (1 - (t-t3) / (t4-t3))\n            # Slight climb during transition\n            val = 2.0 * (t-t3) / (t4-t3)\n            angle_aircraft = 15 * 0.5 * (5 * val^4 * exp(-val^5))\n            return [0, angle_aircraft, 0]\n\n        # ------------ LANDING -------------------------------------------------\n        else\n            return [0, 0, 0]\n        end\n    end\n","category":"page"},{"location":"how-to-guide/define-kinematic-maneuvers/#Define-a-Maneuver","page":"How to Define Kinematic Maneuvers","title":"Define a Maneuver","text":"","category":"section"},{"location":"how-to-guide/define-kinematic-maneuvers/","page":"How to Define Kinematic Maneuvers","title":"How to Define Kinematic Maneuvers","text":"The maneuver is an object that returns the angle of tilting surfaces, RPM of rotor sets, translational velocity and angle of the vehicle. Each of these attributes must be defined as a function of non-dimensional time. Every vehicle attribute must be accounted for, even if a blank function is placed in the object. ","category":"page"},{"location":"how-to-guide/define-kinematic-maneuvers/","page":"How to Define Kinematic Maneuvers","title":"How to Define Kinematic Maneuvers","text":"    angle = (angle_main, angle_tandem)\n    if add_rotors\n        RPM = (RPM_main, RPM_tandem)\n    else\n        RPM = ()\n    end\n    Vvehicle = Vaircraft\n    anglevehicle = angleaircraft\n\n    maneuver = uns.KinematicManeuver(angle, RPM, Vvehicle, anglevehicle)","category":"page"},{"location":"how-to-guide/define-kinematic-maneuvers/","page":"How to Define Kinematic Maneuvers","title":"How to Define Kinematic Maneuvers","text":"warning: Note\n","category":"page"},{"location":"how-to-guide/define-kinematic-maneuvers/","page":"How to Define Kinematic Maneuvers","title":"How to Define Kinematic Maneuvers","text":"    The simulator modifies the velocity and angle of the vehicle by using the derivative velocity and angle functions respectively. The angle, RPM, tilt angle, and velocity functions do not directly define the current motion. This also means that the derivative of each of these functions must be defined (The plot of each function must be continuous.).","category":"page"},{"location":"how-to-guide/define-kinematic-maneuvers/#Define-initial-velocity","page":"How to Define Kinematic Maneuvers","title":"Define initial velocity","text":"","category":"section"},{"location":"how-to-guide/define-kinematic-maneuvers/","page":"How to Define Kinematic Maneuvers","title":"How to Define Kinematic Maneuvers","text":"The initial state of the vehicle must be defined. ","category":"page"},{"location":"how-to-guide/define-kinematic-maneuvers/","page":"How to Define Kinematic Maneuvers","title":"How to Define Kinematic Maneuvers","text":"    Vinit = Vref*maneuver.Vvehicle(0)       # (m/s) initial vehicle velocity\n                                            # (rad/s) initial vehicle angular velocity\n    Winit = pi/180 * (maneuver.anglevehicle(0+1e-12)-\n                                          maneuver.anglevehicle(0))/(ttot*1e-12)","category":"page"},{"location":"how-to-guide/define-kinematic-maneuvers/","page":"How to Define Kinematic Maneuvers","title":"How to Define Kinematic Maneuvers","text":"tip: Note\n","category":"page"},{"location":"how-to-guide/define-kinematic-maneuvers/","page":"How to Define Kinematic Maneuvers","title":"How to Define Kinematic Maneuvers","text":"The initial position, tilt-angle and vehicle angle is defined when defining the geometry.  ","category":"page"},{"location":"how-to-guide/define-kinematic-maneuvers/#Simulate","page":"How to Define Kinematic Maneuvers","title":"Simulate","text":"","category":"section"},{"location":"how-to-guide/define-kinematic-maneuvers/#Generate-a-Simulation-object","page":"How to Define Kinematic Maneuvers","title":"Generate a Simulation object","text":"","category":"section"},{"location":"how-to-guide/define-kinematic-maneuvers/","page":"How to Define Kinematic Maneuvers","title":"How to Define Kinematic Maneuvers","text":"    simulation = uns.Simulation(vehicle, maneuver, Vref, RPMref, ttot;\n                                                    Vinit=Vinit, Winit=Winit)","category":"page"},{"location":"how-to-guide/define-kinematic-maneuvers/#Simulate-or-visualize","page":"How to Define Kinematic Maneuvers","title":"Simulate or visualize","text":"","category":"section"},{"location":"how-to-guide/define-kinematic-maneuvers/","page":"How to Define Kinematic Maneuvers","title":"How to Define Kinematic Maneuvers","text":"    # ----------------- SIMULATION MONITOR -------------------------------------\n    monitor = generate_monitor_vahana(vehicle, rho, RPMref, nsteps, save_path, Vinf)\n\n    # ----------------- RUN SIMULATION -----------------------------------------\n    pfield = uns.run_simulation(simulation, nsteps;\n                                      # OUTPUT OPTIONS\n                                      save_path=save_path,\n                                      run_name=run_name,\n                                      prompt=prompt,\n                                      verbose=verbose, v_lvl=v_lvl,\n                                      save_code=splitdir(@__FILE__)[1]\n                                      )","category":"page"},{"location":"reference/FLOWUnsteadyfunctions/#Functions-Contained-in-FLOWUnsteady","page":"Functions Contained in FLOWUnsteady","title":"Functions Contained in FLOWUnsteady","text":"","category":"section"},{"location":"reference/FLOWUnsteadyfunctions/","page":"Functions Contained in FLOWUnsteady","title":"Functions Contained in FLOWUnsteady","text":"Modules = [FLOWUnsteady]\nOrder   = [:function, :type]","category":"page"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.VLM2VPM-Tuple{Union{FLOWVLM.Rotor, FLOWVLM.Wing, FLOWVLM.WingSystem},Any,Any,Any}","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.VLM2VPM","text":"Receives the FLOWVLM object system (Wing/WingSystem/Rotor), and adds vortex particles to the particle field pfield at each trailing edge position where an infinite vortex starts. dt indicates the length of the interval of time that the vortex shedding represents.\n\nGive it a previous system to detect differences in circulation and add unsteady particles.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.Vvpm_on_Xs-Union{Tuple{T}, Tuple{MyVPM.ParticleField,Array{T,1},String}} where T","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.Vvpm_on_Xs","text":"Returns the velocity induced by particle field on every position Xs\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady._Vkinematic_rotor-Union{Tuple{M}, Tuple{Tuple{Vararg{Array{FLOWVLM.Rotor,1},M}},Tuple{Vararg{Array{FLOWVLM.Rotor,1},M}},Any,Any,Real}} where M","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady._Vkinematic_rotor","text":"Returns the local translational velocity of every midpoint in the ri-th rotor in the si-th system formatted as the output of _get_midXs().\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady._Vkinematic_vlm-Tuple{FLOWUnsteady.AbstractVLMVehicle,Vararg{Any,N} where N}","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady._Vkinematic_vlm","text":"Returns the local translational velocity of every control point in vlm_system.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady._Vkinematic_wake-Tuple{FLOWUnsteady.AbstractVLMVehicle,Vararg{Any,N} where N}","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady._Vkinematic_wake","text":"Returns the local translational velocity of every control point in wake_system.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady._check-Tuple{FLOWUnsteady.AbstractVehicle,FLOWUnsteady.AbstractManeuver}","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady._check","text":"Checks that vehicle and maneuver are compatible.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady._extraVinf1-Tuple{Any,Any}","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady._extraVinf1","text":"Function for FLOWVLM to fetch and add extra velocities to what every control point imposes as the boundary condition\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady._format_blades-Union{Tuple{M}, Tuple{R}, Tuple{Array{Array{R,1},1},Tuple{Vararg{Array{FLOWVLM.Rotor,1},M}},Any,Any}} where M where R","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady._format_blades","text":"Receives the output of `parse_midXs(rotor_systems, midXs, si, ri)` and\n\noutputs the array formatted as blades.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady._get_midX-Tuple{FLOWVLM.Rotor,Int64,Int64}","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady._get_midX","text":"Returns the i-th bound-vortex midpoint of the j-th blade in rotor\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady._get_midXs-Tuple{Array{FLOWVLM.Rotor,1}}","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady._get_midXs","text":"Returns all bound-vortex midpoints in an array of rotors\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady._get_midXs-Tuple{FLOWVLM.Rotor,Int64}","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady._get_midXs","text":"Returns all bound-vortex midpoints of the j-th blade in rotor\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady._get_midXs-Tuple{FLOWVLM.Rotor}","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady._get_midXs","text":"Returns all bound-vortex midpoints in rotor\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady._get_midXs-Union{Tuple{Tuple{Vararg{Array{FLOWVLM.Rotor,1},M}}}, Tuple{M}} where M","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady._get_midXs","text":"Returns all bound-vortex midpoints in multiple rotor systems\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady._parse_midXs-Union{Tuple{M}, Tuple{R}, Tuple{Tuple{Vararg{Array{FLOWVLM.Rotor,1},M}},Array{Array{R,1},N} where N,Any,Any}} where M where R<:Real","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady._parse_midXs","text":"Receives an array midXs formatted as the output of _get_midXs(rotor_systems) and returns the section of the array that corresponds to the ri-th rotor in the si-th system (formatted linearly).\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.add_dV-Tuple{FLOWUnsteady.AbstractVehicle,Any}","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.add_dV","text":"`add_dV(self::AbstractVehicle, dV)`\n\nIncrements the velocity of the vehicle by dV.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.add_dW-Tuple{FLOWUnsteady.AbstractVehicle,Any}","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.add_dW","text":"`add_dW(self::AbstractVehicle, dV)`\n\nIncrements the angular velocity of the vehicle by dW.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.calc_ReD-Tuple{Any,Any,Vararg{Any,N} where N}","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.calc_ReD","text":"Reynolds number at radial station r (m)\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.calc_aerodynamicforce-Tuple{Union{FLOWVLM.Wing, FLOWVLM.WingSystem},Any,Any,Any,Any,Any}","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.calc_aerodynamicforce","text":"Calculates the aerodynamic force at each element of a VLM system using it's\n\ncurrent Gamma solution, the velocity induced by the particle field pfield, and the kinematic velocity calculated from prev_vlm_system. It saves the force as the field vlm_system.sol[\"Ftot\"]\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.calc_cbar-Tuple{FLOWVLM.Rotor}","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.calc_cbar","text":"Returns the mean chord of the blade of the given rotor\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.calc_dV-Tuple{FLOWUnsteady.AbstractManeuver,FLOWUnsteady.AbstractVehicle,Real,Real,Real,Real}","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.calc_dV","text":"`calc_dV(maneuver::AbstractManeuver, vehicle::Vehicle, t, dt, ttot, Vref)`\n\nReturns the change in velocity dV=[dVx, dVy, dVz] (m/s) of vehicle performing maneuver at time t (s) after a time step dt (s).  Vref and tot are the reference velocity and the total time at which this maneuver is being performed, respectively. dV is in the global reference system.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.calc_dW-Tuple{FLOWUnsteady.AbstractManeuver,FLOWUnsteady.AbstractVehicle,Real,Real,Real}","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.calc_dW","text":"`calc_dw(maneuver::AbstractManeuver, vehicle::Vehicle, t, dt, Vref, ttot)`\n\nReturns the change in angular velocity dW=[dWx, dWy, dWz] (about global axes, in radians) of vehicle performing maneuver at time t (s) after a time step dt (s). ttot is the total time at which this maneuver is to be performed.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.calc_n-NTuple{5,Any}","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.calc_n","text":"Given a diameter-based Reynolds number $\\mathrm{Re}_D(r)$ at a certain\n\nradial position r and an advance ratio J, return the rotational speed\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.decompose-Tuple{Any,Any,Any}","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.decompose","text":"Receives an array of vectors Fs and decomposes them into components in the ihat, jhat, khat unitary orthogonal directions (khat is deduced).\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.generate_monitor_rotors-Tuple{Array{FLOWVLM.Rotor,1},Real,Real,Real,Int64}","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.generate_monitor_rotors","text":"`generate_monitor_rotors( rotors::Array{vlm.Rotor, 1}, J_ref::Real,\n\nrhoref::Real, RPMref::Real, nsteps_sim::Int)`\n\nGenerate monitor of load distribution and performance of a rotor system. J_ref and rho_ref are the reference advance ratio and air density used for calculating propulsive efficiency and coefficients. RPM_ref is the reference RPM used to estimate the age of the wake. nsteps_sim is the number of time steps by the end of the simulation (used for generating the color gradient).\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.generate_monitor_wing-Tuple{Any,Function,Real,Real,Real,Real,Int64}","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.generate_monitor_wing","text":"`generate_monitor_wing(wing, Vinf::Function, b_ref::Real, ar_ref::Real,\n\nrhoref::Real, qinfref::Real, nsteps_sim::Int)`\n\nGenerate monitor of load distribution and performance of a wing.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.generate_rotor-Tuple{Real,Real,Int64,Array{Float64,2},Array{Float64,2},Array{Float64,2},Array{Float64,2},Array{Tuple{Float64,String,String},1}}","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.generate_rotor","text":"Generates the Rotor object. pitch is the pitch of the blades in degrees, n is the number of lattices in the VLM.\n\nReD is the diameter Reynolds number based on rotational speed calculated as ReD = (omegaR)(2*R)/nu, and Matip is the rotational+freestream Mach number at the tip. This values are used for calculate airfoil properties through XFOIL (chord Reynolds), so ignore them if airfoil properties are prescribed.\n\nGive it altReD = [RPM, J, nu], and it'll calculate the chord-based Reynolds accounting for the effective velocity at every station ignoring ReD (this is more accurate, but not needed).\n\nNOTE: If Matip is different than zero while running XFOIL, remember to deactive compressibility corrections when running vlm.solvefromCCBlade() by giving it sound_spd=nothing\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.generate_static_particle_fun-Tuple{FLOWUnsteady.AbstractVehicle,Real}","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.generate_static_particle_fun","text":"Returns a function that generates an array of particles representing the surface of the vehicle as a collection of vortex particles.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.generate_vtkliftinglines-Tuple{Any,Any,Any}","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.generate_vtkliftinglines","text":"Generate lifting lines for acoustic compact patches of rotors\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.generate_wopwoploading-Tuple{Any,Any,Any}","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.generate_wopwoploading","text":"Generates loading files for PSU-WOPWOP from the indicated simulation in\n\nread_path using the steps nums. If woptype=Constant, only one step must be specified; if woptype=Periodic, it is assumed that the specified steps make one and only one full revolution; if woptype=Aperiodic, it is assumed that the specified steps make one and only one full revolution. This function outputs the load per unit length in the global coordinate system if periodic, or in the blade coordinate system if constant.\n\nNOTE: If periodic, there should be steps from 0 degrees up to 360 degrees (or up to whether the periodic angle is) where nums[1] matches the same conditions than nums[end] (rotor simulations with this module will do this by default). The period of one revolution should be indicated under period.\n\nNOTE2: dt must be the same time step than specified in the PSU-WOPWOP driver.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.get_RPM-Tuple{FLOWUnsteady.AbstractManeuver,Int64,Real}","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.get_RPM","text":"`get_RPM(maneuver::AbstractManeuver, i::Int, t::Real)`\n\nReturns the normalized RPM of the i-th rotor system at the non-dimensional time t.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.get_RPMs-Tuple{FLOWUnsteady.AbstractManeuver,Real}","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.get_RPMs","text":"`get_RPMs(maneuver::AbstractManeuver, t::Real)`\n\nReturns the normalized RPM of every rotor systems at the non-dimensional time t.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.get_angle-Tuple{FLOWUnsteady.AbstractManeuver,Int64,Real}","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.get_angle","text":"`get_angle(maneuver::AbstractManeuver, i::Int, t::Real)`\n\nReturns the angle (in degrees) of the i-th tilting system at the non-dimensional time t.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.get_angles-Tuple{FLOWUnsteady.AbstractManeuver,Real}","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.get_angles","text":"`get_angles(maneuver::AbstractManeuver, t::Real)`\n\nReturns the angle (in degrees) of every tilting systems at the non-dimensional time t.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.get_nrtrsys-Tuple{FLOWUnsteady.AbstractManeuver}","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.get_nrtrsys","text":"`get_nrtrsys(self::AbstractManeuver)`\n\nReturn number of rotor systems.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.get_nrtrsys-Tuple{FLOWUnsteady.AbstractVehicle}","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.get_nrtrsys","text":"`get_nrtrsys(self::AbstractVehicle)`\n\nReturn number of rotor systems.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.get_ntltsys-Tuple{FLOWUnsteady.AbstractManeuver}","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.get_ntltsys","text":"`get_ntltsys(self::AbstractManeuver)`\n\nReturn number of tilting systems.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.get_ntltsys-Tuple{FLOWUnsteady.AbstractVehicle}","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.get_ntltsys","text":"`get_ntltsys(self::AbstractVehicle)`\n\nReturn number of tilting systems.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.nextstep_kinematic-Tuple{FLOWUnsteady.AbstractVehicle,Real}","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.nextstep_kinematic","text":"`nextstep_kinematic(self::AbstractVehicle, dt::Real)`\n\nTranslates and rotates the vehicle in a time step dt according to current linear and angular velocity.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.nextstep_kinematic-Tuple{FLOWUnsteady.Simulation,Real}","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.nextstep_kinematic","text":"`nextstep_kinematic(self::Simulation, dt::Real)`\n\nTakes a kinematic time step dt where the new velocity and angular velocity is calculated and the vehicle is translated and rotated according to it. It also updates the tilt angle and RPM of every system.\n\nNOTE: No solver is run in this process, rather it uses the current aerodynamic solution to calculate acceleration and moment.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.plot_maneuver-Tuple{FLOWUnsteady.KinematicManeuver}","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.plot_maneuver","text":"`plot_maneuver(maneuver::KinematicManeuver; ti::Real=0, tf::Real=1,\n\nvis_nsteps=300, figname=\"maneuver\", tstages=[])`\n\nPlots the kinematics and controls of a KinematicManeuver.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.precalculations-Tuple{FLOWUnsteady.AbstractVLMVehicle,Function,MyVPM.ParticleField,Real,Real,Int64}","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.precalculations","text":"Precalculations before calling the solver.\n\nCalculates kinematic velocity on VLM an adds them as a solution field\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.precalculations-Tuple{FLOWUnsteady.AbstractVehicle,Function,MyVPM.ParticleField,Real,Real}","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.precalculations","text":"`precalculations(self, pfield, t, dt)`\n\nPrecalculations before calling the solver and before shedding trialing wake.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.precalculations-Tuple{FLOWUnsteady.Simulation,Function,MyVPM.ParticleField,Real,Real}","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.precalculations","text":"Precalculations before calling the solver.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.rotate_observers-Tuple{Any,Any}","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.rotate_observers","text":"Rotate observer(s) as the BPM code assumes wind is in the x-y plane. (So for a rotor in hover, the rotors are offset by 90 deg. We can instead rotate the observers to get the same results.)\n\nθ is in degrees.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.run_noise_bpm-Tuple{Array{FLOWVLM.Rotor,1},Real,Function,Real,Real,Real,String}","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.run_noise_bpm","text":"Calculates broadband noise from the Brooks, Pope and Marcolini method using the BPM.jl package.\n\nThe function writes the data to a file that can be read in postprocessing     with FLOWNoise.readwopwopoutput(). It writes three files: SPL     (non-weighted), A-weighted SPL, and OASPL.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.run_noise_wopwop-Tuple{String,Any,Real,Real,Real,Any,Any,Any,String,Any}","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.run_noise_wopwop","text":"Given the path of a FLOWUnsteady simulation, it runs the noise analysis on the rotors of the simulation. It uses PSU-WOPWOP to calculate the tonal noise from thickness and loading sources on the geometry and aerodynamic loading generated by FLOWUnsteady.\n\nNOTE: This function will call the PSU-WOPWOP binary indicated through wopwopbin. This binary is not included with FLOWUnsteady and must be provided by the user. This function has been tested on PSU-WOPWOP v3.4.2.\n\nNOTE2: Make sure that the simulation was run with nsteps_save=1, otherwise the time in PSU-WOPWOP will get messed up.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.save_vtk-Tuple{FLOWUnsteady.AbstractVehicle,Any}","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.save_vtk","text":"`save_vtk(self::AbstractVehicle, filename; path=nothing, num=nothing,\n\noptargs...)`\n\nOutput VTK files with vehicle geometry and solution fields.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.set_V-Tuple{FLOWUnsteady.AbstractVehicle,Any}","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.set_V","text":"`set_V(self::AbstractVehicle, V)`\n\nSet current vehicle velocity to V.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.set_W-Tuple{FLOWUnsteady.AbstractVehicle,Any}","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.set_W","text":"`set_W(self::AbstractVehicle, W)`\n\nSet current vehicle angular velocity to W.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.shed_wake-Tuple{FLOWUnsteady.AbstractVehicle,Function,MyVPM.ParticleField,Real}","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.shed_wake","text":"Shed VPM wake. If unsteady_shedcrit<=0 it sheds wake due to loading distribution, otherwise it will shed wake due to unsteady loading.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.tilt_systems-Tuple{FLOWUnsteady.AbstractVehicle,Any}","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.tilt_systems","text":"`nextstep_kinematic(self::AbstractVehicle, angles)`\n\nTilts every tilting system of this vehicle into its corresponding new angle, where angles[i]=[Ax, Ay, Az] is the new angle of the i-th tilting system (in degrees).\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.visualize_kinematics-Union{Tuple{M}, Tuple{N}, Tuple{R}, Tuple{V}, Tuple{FLOWUnsteady.Simulation{V,FLOWUnsteady.KinematicManeuver{N,M},R},Int64,String}} where M where N where R<:Real where V<:FLOWUnsteady.AbstractVehicle","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.visualize_kinematics","text":"`visualize_kinematics(sim::Simulation, nsteps::Int, save_path::String)`\n\nGenerate VTKs of the kinematics of this simulation.\n\n\n\n\n\n","category":"method"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.AbstractManeuver","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.AbstractManeuver","text":"`AbstractManeuver{N, M}`\n\nN indicates the number of tilting systems in this maneuver, while and M indicates the number of rotor systems.\n\nEvery implementation of AbstractManeuver must have the properties:\n\nangle::NTuple{N, Function} where angle[i](t) returns the angle of the      i-th tilting system at time t (t is nondimensionalized by the total      time of the maneuver, from 0 to 1, beginning to end).\nRPM::NTuple{M, Function} where RPM[i](t) returns the normalized RPM of      the i-th rotor system at time t. This RPM values are normalized by the      an arbitrary RPM value (usually RPM in hover or cruise).\n\n\n\n\n\n","category":"type"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.AbstractVLMVehicle","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.AbstractVLMVehicle","text":"`AbstractVLMVehicle{N, M, R} <: AbstractVehicle{N, M, R}`\n\nImplementations of AbstractUVLMVehicle are expected to have the following fields:\n\nRequired inputs\n\nsystem::vlm.WingSystem\n\nOptional inputs\n\ntilting_systems::NTuple{N, vlm.WingSystem}\nrotor_systems::NTuple{M, Array{vlm.Rotor, 1}}\nvlm_system::vlm.WingSystem\nwake_system::vlm.WingSystem\ngrids::Array{gt.GridTypes, 1}\n\nInternal properties\n\nV::Array{R, 1}                          # Current vehicle velocity\nW::Array{R, 1}                          # Current vehicle angular velocity\nprev_data::Array{Any, 1}                # Information about previous step\ngrid_O::Array{Array{R, 1}, 1}           # Origin of every grid\n\nThey also need to implement the following functions required by AbstractVehicle:\n\nshed_wake(...)\ngenerate_static_particle_fun(...)\nsave_vtk(...)\n\nSee the documentation and code of AbstractVehicle for more details.\n\nIn general, in order for implementation to work correctly, it is required that the components of wake_system are also components of either vlm_system or rotor_systems, and that none of the components of rotor_systems are also components of vlm_system.\n\n\n\n\n\n","category":"type"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.AbstractVehicle","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.AbstractVehicle","text":"`AbstractVehicle{N, M, R}`\n\nType handling all geometries and subsystems that define a flight vehicle.\n\nN indicates the number of tilting systems in this vehicle, while and M indicates the number of rotor systems. R is a Real type.\n\nImplementations must have the following properties:     * V::Array{R, 1}          : Current velocity vector of the vehicle in the                                     global coordinate system.     * W::Array{R, 1}          : Current angular velocity vector of the vehicle                                     in the global coordinate system.\n\n\n\n\n\n","category":"type"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.KinematicManeuver","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.KinematicManeuver","text":"`KinematicManeuver(angle, RPM, Vvehicle, anglevehicle)`\n\nA vehicle maneuver where the kinematic are prescribed.\n\nARGUMENTS\n\nangle::NTuple{N, Function} where angle[i](t) returns the angles       [Ax, Ay, Az] (in degrees)of the i-th tilting system at time t (t is       nondimensionalized by the total time of the maneuver, from 0 to 1,       beginning to end).\nRPM::NTuple{M, Function} where RPM[i](t) returns the normalized RPM of       the i-th rotor system at time t. This RPM values are normalized by the       an arbitrary RPM value (usually RPM in hover or cruise).\nVvehicle::Function where Vvehicle(t) returns the normalized vehicle       velocity [Vx, Vy, Vz] at the normalized time t. Velocity is       normalized by a reference velocity (typically, cruise velocity).\nanglevehicle::Function where anglevehicle(t) returns the angles       [Ax, Ay, Az] (in degrees) of the vehicle relative to the global       coordinate system at the normalized time t.\n\n\n\n\n\n","category":"type"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.QVLMVehicle","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.QVLMVehicle","text":"`QVLMVehicle(system; optargs...)`\n\nType handling all geometries and subsystems that define a flight vehicle made out of VLM (Wing, WingSystem, Rotor) components.\n\nNOTE: For the solver to work correctly, all components in wake_system (if any) need to be also components of vlm_system.\n\nNOTE: It is recommended that wake_system doesn't include any Rotor object. Otherwise, blades will generate a wake going straight out of every blade trailing edge pointing oposite to the direction of rotation instead of generating a streamtube.\n\nARGUMENTS\n\nsystem::vlm.WingSystem:        System of all FLOWVLM objects. This system                                   is considered as the entire vehicle. Not all                                   components in this system will be solved,                                   but they will all be rotated and translated                                   during maneuver.\n\nOPTIONAL ARGUMENTS\n\ntilting_systems::Tuple(vlm.WingSystem, ...):   Tuple of all FLOWVLM                                   tilting objects, where tilting_systems[i]                                   contains the i-th FLOWVLM system of lifting                                   surfaces and rotors that tilt together.\nrotors_systems::Tuple(Array{vlm.Rotor,1}, ...):   Tuple of groups of Rotors                                   that share a common RPM.\nvlm_system::vlm.WingSystem:    System of all FLOWVLM objects to be solved                                   through the VLM solver.\nwake_system::vlm.WingSystem:   System of all FLOWVLM objects that will                                   have a rigid, semi-infinite VLM wake.\ngrids::Array{gt.GridTypes, 1}: Array of grids that will be translated and                                   rotated along with system.\n\n\n\n\n\n","category":"type"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.Simulation","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.Simulation","text":"`Simulation(vehicle, maneuver, Vref::Real, RPMref::R, ttot:R)`\n\nSimulation interface. This type carries the simulation's options and connects vehicle and maneuver together.\n\n\n\n\n\n","category":"type"},{"location":"reference/FLOWUnsteadyfunctions/#FLOWUnsteady.UVLMVehicle","page":"Functions Contained in FLOWUnsteady","title":"FLOWUnsteady.UVLMVehicle","text":"`UVLMVehicle(system; optargs...)`\n\nType handling all geometries and subsystems that define a flight vehicle made out of VLM (Wing, WingSystem, Rotor) components.\n\nARGUMENTS\n\nsystem::vlm.WingSystem:        System of all FLOWVLM objects. This system                                   is considered as the entire vehicle. Not all                                   components in this system will be solved,                                   but they will all be rotated and translated                                   during maneuver.\n\nOPTIONAL ARGUMENTS\n\ntilting_systems::Tuple(vlm.WingSystem, ...):   Tuple of all FLOWVLM                                   tilting objects, where tilting_systems[i]                                   contains the i-th FLOWVLM system of lifting                                   surfaces and rotors that tilt together.\nrotors_systems::Tuple(Array{vlm.Rotor,1}, ...):   Tuple of groups of Rotors                                   that share a common RPM.\nvlm_system::vlm.WingSystem:    System of all FLOWVLM objects to be solved                                   through the VLM solver.\nwake_system::vlm.WingSystem:   System of all FLOWVLM objects that will                                   shed a VPM wake.\ngrids::Array{gt.GridTypes, 1}: Array of grids that will be translated and                                   rotated along with system.\n\n\n\n\n\n","category":"type"},{"location":"how-to-guide/define-complex-wings/#How-to-define-Complex-Wings","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"","category":"section"},{"location":"how-to-guide/define-complex-wings/","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"In the tutorial First Steps we introduced the simpleWing() function.  In this guide, we look at creating more complex wings using the complexWing() function. Note that this is a how to guide, showing how to use the complexWing() function. For details on this function implementation, please refer to the refernce section of this documentation.","category":"page"},{"location":"how-to-guide/define-complex-wings/#Define-a-Symmetric-Wing","page":"How to define Complex Wings","title":"Define a Symmetric Wing","text":"","category":"section"},{"location":"how-to-guide/define-complex-wings/","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"In order to use the complexWing() function, we only need to understand that we are responsible for defining the elements of each chord section individually, which gives us greater flexibility than the simpleWing() function, where many assumptions are made for the user.","category":"page"},{"location":"how-to-guide/define-complex-wings/","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"Let us begin by defining some of the wing parameters","category":"page"},{"location":"how-to-guide/define-complex-wings/","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"span = 1.0                      #length of full span\nnumlattice = 10                 #number of lattice elements on half-span","category":"page"},{"location":"how-to-guide/define-complex-wings/","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"Now let's define the parameters of each chord.  Note that position is normalized by the span, and length is normalized by the tip chord. It is generally easiest to define things absolutely and then normalize.","category":"page"},{"location":"how-to-guide/define-complex-wings/","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"Also, since we are creating a symmetric wing, we only need information from the center to the tip of the wing, postive indicating along the positive axis for the wing system.","category":"page"},{"location":"how-to-guide/define-complex-wings/","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"poschord = [0.0; 0.5; 1.0]./span                    #postion of chord stations\nlengthtipchord = 0.03                               #length of tip chord\nlengthchord = [0.075; 0.05; 0.03]./lengthtipchord   #length of chords\ntwistchord = [0.0; 0.0; -3.0]                       #twist of chords, in degrees","category":"page"},{"location":"how-to-guide/define-complex-wings/","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"Then let's define the parameters of each section between chord definitions.","category":"page"},{"location":"how-to-guide/define-complex-wings/","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"sweepsection = [10.0; 5.0]      #sweep of sections between chords, in degrees\ndihedralsection = [0.0; 7.0]    #dihedral of sections between chords, in degrees","category":"page"},{"location":"how-to-guide/define-complex-wings/","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"We also need to define the aspect ratio of the wing, which is simply the absolute span over the absolute tip chord length.","category":"page"},{"location":"how-to-guide/define-complex-wings/","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"aspectratio = span/lengthtipchord","category":"page"},{"location":"how-to-guide/define-complex-wings/","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"With this, we can call the complexWing() function for a symmetric wing.","category":"page"},{"location":"how-to-guide/define-complex-wings/","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"mainwing = vlm.complexWing(span, aspectratio, numlattice, poschord, lengthchord, twistchord, sweepsection, dihedralsection; symmetric=true)","category":"page"},{"location":"how-to-guide/define-complex-wings/","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"(Image: symmetric wing)","category":"page"},{"location":"how-to-guide/define-complex-wings/#Define-a-Non-symmetric-Wing","page":"How to define Complex Wings","title":"Define a Non-symmetric Wing","text":"","category":"section"},{"location":"how-to-guide/define-complex-wings/","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"A good example of a non-symmetric wing is something like a vertical stabilizer. The definitions are basically the same, we just set the symmetric flag to false when creating the wing.","category":"page"},{"location":"how-to-guide/define-complex-wings/","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"span = 0.25                             #length of full span\nnumlattice = 5                          #number of lattice elements on half-span\nposchord = [0.0; 1.0]                   #postion of chord stations\nlengthtipchordvstab = 0.05              #length of tip chord\nlengthchordvstab = [1.25; 1.0]          #length of chords\ntwistchord = [0.0; 0.0]                 #twist of chords, in degrees\nsweepsection = [0.0]                    #sweep of sections between chords, in degrees\ndihedralsection = [0.0]                 #dihedral of sections between chords, in degrees\naspectratio = span/lengthtipchordvstab\n\nverticalstabilizer = vlm.complexWing(span, aspectratio, numlattice, poschord, lengthchordvstab, twistchord, sweepsection, dihedralsection; symmetric=false, chordalign=1.0)","category":"page"},{"location":"how-to-guide/define-complex-wings/","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"note: Chord Alignment\nThe user can choose where to align the chords. A value of 0.0 aligns along the leading edge, while a value of 1.0 aligns along the trailing edge. Values between 0.0 and 1.0 will align along that ratio of the chord lengths.  For example, if you wanted to align the wing along the quarter-chord postition, you would set chordalign = 0.25","category":"page"},{"location":"how-to-guide/define-complex-wings/","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"Now our verticle stabilizer is defined, but it's not really verticle yet, and it is positioned at the default location, where our main wing is as well.  To make it a verticle stabilizer, we'll need to rotate and translate it.  To do so, we need to define an origin and coordinate system for the verticle stabilizer wing object.","category":"page"},{"location":"how-to-guide/define-complex-wings/","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"originvstab = [0.5; 0.0; 0.0]                       #origin moved 0.5 in positive x-direction\ncsysvstab = [1.0 0.0 0.0; 0.0 0.0 1.0; 0.0 1.0 0.0] #csys rotated 90 degrees from default","category":"page"},{"location":"how-to-guide/define-complex-wings/","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"Then we can set the coordianate system.","category":"page"},{"location":"how-to-guide/define-complex-wings/","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"vlm.setcoordsystem(verticalstabilizer,originvstab,csysvstab)","category":"page"},{"location":"how-to-guide/define-complex-wings/","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"(Image: non-symmetric wing)","category":"page"},{"location":"how-to-guide/define-complex-wings/#Define-Control-Surfaces","page":"How to define Complex Wings","title":"Define Control Surfaces","text":"","category":"section"},{"location":"how-to-guide/define-complex-wings/","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"There is no automatic way to define control surfaces. Each control surface will need to be defined as its own wing object and placed manually. Therefore, you must adjust based on the objects already in place. Let's add a rudder to our verticle stabilizer.","category":"page"},{"location":"how-to-guide/define-complex-wings/","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"span = 0.25                        #length of full span\nnumlattice = 5                     #number of lattice elements on half-span\nposchord = [0.0; 0.25; 1.0]        #postion of chord stations\nlengthtipchord = 0.03              #length of tip chord\nlengthchord = [1.25; 1.5; 1.0]     #length of chords\ntwistchord = [0.0; 0.0; 0.0]       #twist of chords, in degrees\nsweepsection = [0.0; 0.0]          #sweep of sections between chords, in degrees\ndihedralsection = [0.0; 0.0]       #dihedral of sections between chords, in degrees\naspectratio = span/lengthtipchord\n\nrudder = vlm.complexWing(span, aspectratio, numlattice, poschord, lengthchord, twistchord, sweepsection, dihedralsection; symmetric=false, chordalign=0.0)\n\nlengthrootchordvstab = lengthchordvstab[1]*lengthtipchordvstab\noriginrudder = [0.5+lengthrootchordvstab; 0.0; 0.0]  #account for vstab position and chord\ncsysrudder = [1.0 0.0 0.0; 0.0 0.0 1.0; 0.0 1.0 0.0] #csys rotated 90 degrees from default\nvlm.setcoordsystem(rudder,originrudder,csysrudder)","category":"page"},{"location":"how-to-guide/define-complex-wings/","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"(Image: rudder)","category":"page"},{"location":"how-to-guide/define-complex-wings/","page":"How to define Complex Wings","title":"How to define Complex Wings","text":"span = 1.0                      #length of full span\nnumlattice = 10                 #number of lattice elements on half-span\n\nposchord = [0.0; 0.5; 1.0]./span                #postion of chord stations\nlengthtipchord = 0.03                            #length of tip chord\nlengthchord = [0.075; 0.05; 0.03]./lengthtipchord   #length of chords\ntwistchord = [0.0; 0.0; -3.0]                   #twist of chords, in degrees\nsweepsection = [10.0; 5.0]      #sweep of sections between chords, in degrees\ndihedralsection = [0.0; 7.0]    #dihedral of sections between chords, in degrees\naspectratio = span/lengthtipchord\n\nmainwing = FLOWVLM.complexWing(span, aspectratio, numlattice, poschord, lengthchord, twistchord, sweepsection, dihedralsection; symmetric=true)\n\n\nspan = 0.25                                     #length of full span\nnumlattice = 5                                  #number of lattice elements on half-span\nposchord = [0.0; 1.0]                #postion of chord stations\nlengthtipchordvstab = 0.05                          #length of tip chord\nlengthchordvstab = [1.25; 1.0]     #length of chords\ntwistchord = [0.0; 0.0]                         #twist of chords, in degrees\nsweepsection = [0.0]                      #sweep of sections between chords, in degrees\ndihedralsection = [0.0]                    #dihedral of sections between chords, in degrees\naspectratio = span/lengthtipchordvstab\n\nverticalstabilizer = FLOWVLM.complexWing(span, aspectratio, numlattice, poschord, lengthchordvstab, twistchord, sweepsection, dihedralsection; symmetric=false, chordalign=1.0)\n\noriginvstab = [0.5; 0.0; 0.0]                       #origin moved 0.5 in positive x-direction\ncsysvstab = [1.0 0.0 0.0; 0.0 0.0 1.0; 0.0 1.0 0.0] #csys rotated 90 degrees from default\nFLOWVLM.setcoordsystem(verticalstabilizer,originvstab,csysvstab)\n\n\n\nspan = 0.25                                     #length of full span\nnumlattice = 5                                  #number of lattice elements on half-span\nposchord = [0.0; 0.25; 1.0]                #postion of chord stations\nlengthtipchord = 0.03                          #length of tip chord\nlengthchord = [1.25; 1.5; 1.0]     #length of chords\ntwistchord = [0.0; 0.0; 0.0]                         #twist of chords, in degrees\nsweepsection = [0.0; 0.0]                      #sweep of sections between chords, in degrees\ndihedralsection = [0.0; 0.0]                    #dihedral of sections between chords, in degrees\naspectratio = span/lengthtipchord\n\nrudder = FLOWVLM.complexWing(span, aspectratio, numlattice, poschord, lengthchord, twistchord, sweepsection, dihedralsection; symmetric=false, chordalign=0.0)\n\nlengthrootchordvstab = lengthchordvstab[1]*lengthtipchordvstab\noriginrudder = [0.5+lengthrootchordvstab; 0.0; 0.0]                       #account for vstab position and chord\ncsysrudder = [1.0 0.0 0.0; 0.0 0.0 1.0; 0.0 1.0 0.0] #csys rotated 90 degrees from default\nFLOWVLM.setcoordsystem(rudder,originrudder,csysrudder)\n\n\nsystem = FLOWVLM.WingSystem()\nFLOWVLM.addwing(system,\"mainwing\",mainwing)\nFLOWVLM.addwing(system,\"vstab\",verticalstabilizer)\nFLOWVLM.addwing(system,\"rudder\",rudder)\n\nVinf(x,t) = [1,0,0]         #non-dimensional function defining free stream velocity\nFLOWVLM.setVinf(system, Vinf)   #set freestream velocity for the system\n\nrun_name = \"tutorial\"           #define identifier at beginning of file names\nsave_path = \"./simplewing/\"     #define directory where files will be saved\n\nrun(`rm -rf $save_path`)        #clear out directory where files will be saved\nrun(`mkdir $save_path`)         #re-create directory fresh\n\nFLOWVLM.save(system, run_name; path=save_path)  #save geometry in a .vtk file format\nrun(`paraview`)","category":"page"},{"location":"how-to-guide/define-complex-wings/#Define-things-Manually","page":"How to define Complex Wings","title":"Define things Manually","text":"","category":"section"},{"location":"how-to-guide/set-up-runtime-functions/#How-to-Set-up-Run-time-Functions","page":"How to Set up Run-time Functions","title":"How to Set up Run-time Functions","text":"","category":"section"},{"location":"how-to-guide/set-up-runtime-functions/","page":"How to Set up Run-time Functions","title":"How to Set up Run-time Functions","text":"FLOWUnsteady allows for the definition of additional run-time functions, which are passed into the keyword argument, extra_runtime_function, in the run_simulation() function.","category":"page"},{"location":"how-to-guide/set-up-runtime-functions/","page":"How to Set up Run-time Functions","title":"How to Set up Run-time Functions","text":"These are typically formatted as follows:","category":"page"},{"location":"how-to-guide/set-up-runtime-functions/","page":"How to Set up Run-time Functions","title":"How to Set up Run-time Functions","text":"function customfunction(inputs)\n\n    function extra_runtime_function(sim, pfield, t, dt)\n\n        #insert your function here\n\n        return false\n\n    end\n\nend","category":"page"},{"location":"how-to-guide/set-up-runtime-functions/","page":"How to Set up Run-time Functions","title":"How to Set up Run-time Functions","text":"If you have more than one additional function you'd like to run, a nice way for allowing arbitrarily defined functions is to define an encapsulating functions with the args... command such as","category":"page"},{"location":"how-to-guide/set-up-runtime-functions/","page":"How to Set up Run-time Functions","title":"How to Set up Run-time Functions","text":"customfunc1 = customfunction1(inputs1)\ncustomfunc2 = customfunction2(inputs2)\nextrafunctions(args...) = customfunc1(args...) || customfunc2(args...)","category":"page"},{"location":"how-to-guide/set-up-runtime-functions/#Creating-Monitors","page":"How to Set up Run-time Functions","title":"Creating Monitors","text":"","category":"section"},{"location":"how-to-guide/set-up-runtime-functions/","page":"How to Set up Run-time Functions","title":"How to Set up Run-time Functions","text":"By incorporating plots into an extra runtime function, you can create monitors that will show you the progress of the simulation.  The definition of these very much depends on your use case. For the creators, aerodynamic forces are important, so we'll cover that now.","category":"page"},{"location":"how-to-guide/set-up-runtime-functions/#Calculating-Aerodynamic-Forces","page":"How to Set up Run-time Functions","title":"Calculating Aerodynamic Forces","text":"","category":"section"},{"location":"how-to-guide/set-up-runtime-functions/","page":"How to Set up Run-time Functions","title":"How to Set up Run-time Functions","text":"FLOWUnsteady has some functions that assist in calculating aerodynamic forces.  Specifically, the calc_aerodynamicforces() function and the decompose() function.","category":"page"},{"location":"how-to-guide/set-up-runtime-functions/","page":"How to Set up Run-time Functions","title":"How to Set up Run-time Functions","text":"To get the total forces on a wing object, you need the current and previous wing state, as well as the freestream velocity and density.","category":"page"},{"location":"how-to-guide/set-up-runtime-functions/","page":"How to Set up Run-time Functions","title":"How to Set up Run-time Functions","text":"Ftot = uns.calc_aerodynamicforces(currentwingobject,priorstepwingobject, pfield, Vinf, dt, rhoinf)","category":"page"},{"location":"how-to-guide/set-up-runtime-functions/","page":"How to Set up Run-time Functions","title":"How to Set up Run-time Functions","text":"note: Previous Wing\nIn order to save the previous wing, it is convenient to initialize prevwing to nothing before entering the extraruntime function, and using deep copy at the end of the extra runtime function (before returning false).function customfunc(inputs)\n\n    prev_wing = nothing\n\n    extra_runtime_function(sim,pfield,t,dt)\n\n        #custom function\n\n        prev_wing = deepcopy(wing)\n\n        return false\n\n    end\n\nend","category":"page"},{"location":"how-to-guide/set-up-runtime-functions/","page":"How to Set up Run-time Functions","title":"How to Set up Run-time Functions","text":"This gives you the total forces on the overall wing. If you want the forces on each section of the wing, you'd have to set the per_unit_span boolean keyword argument to true","category":"page"},{"location":"how-to-guide/set-up-runtime-functions/","page":"How to Set up Run-time Functions","title":"How to Set up Run-time Functions","text":"ftot = uns.calc_aerodynamicforces(currentwingobject,priorstepwingobject, pfield, Vinf, dt, rhoinf; per_unit_span=true)","category":"page"},{"location":"how-to-guide/set-up-runtime-functions/","page":"How to Set up Run-time Functions","title":"How to Set up Run-time Functions","text":"To get the respective Lift, Drag, and Sideslip forces, you need to pass the total force vector into the decompose() function along with two orthogonal vectors indicating what direction the forces are acting.","category":"page"},{"location":"how-to-guide/set-up-runtime-functions/","page":"How to Set up Run-time Functions","title":"How to Set up Run-time Functions","text":"For example, for steady, level flight in the typical aerodynamics frame, you could do","category":"page"},{"location":"how-to-guide/set-up-runtime-functions/","page":"How to Set up Run-time Functions","title":"How to Set up Run-time Functions","text":"L, D, S = uns.decompose(Ftot,[0,0,1],[1,0,0])","category":"page"},{"location":"how-to-guide/set-up-runtime-functions/","page":"How to Set up Run-time Functions","title":"How to Set up Run-time Functions","text":"Where lift is in the positive z-direction, or [0,0,1] and drag is in the positive x-direction, or [1,0,0].  The decompose function only needs the directions for the first two outputs, and then it calculates the third vector.","category":"page"},{"location":"how-to-guide/set-up-runtime-functions/","page":"How to Set up Run-time Functions","title":"How to Set up Run-time Functions","text":"note: Arbitrary Force Vectors\nBecause of how the decompose function is defined, you have no limits on what forces you calculate. That is to say, you can find the forces in any reference frame.  This also makes the user responsible for defining exactly what they want to use as the Lift vector, etc.","category":"page"},{"location":"how-to-guide/set-up-runtime-functions/#Adding-data-to-output-files","page":"How to Set up Run-time Functions","title":"Adding data to output files","text":"","category":"section"},{"location":"how-to-guide/set-up-runtime-functions/","page":"How to Set up Run-time Functions","title":"How to Set up Run-time Functions","text":"By passing, say, a wing object into an extra runtime function, you can use the _addsolution() function in the VLM module to add data to the .vtk files output by the simulation.  This way, you can visualize in Paraview things such as forces and velocities in addition to the default outputs.","category":"page"},{"location":"how-to-guide/set-up-runtime-functions/","page":"How to Set up Run-time Functions","title":"How to Set up Run-time Functions","text":"For example, if you had calculated Lift and Drag, and wanted to include those in the files used in Paraview visualization you could run the commands","category":"page"},{"location":"how-to-guide/set-up-runtime-functions/","page":"How to Set up Run-time Functions","title":"How to Set up Run-time Functions","text":"vlm._addsolution(wingobject,\"Lift\",Lift)\nvlm._addsolution(wingobject,\"Drag\",Drag)","category":"page"},{"location":"how-to-guide/set-up-runtime-functions/","page":"How to Set up Run-time Functions","title":"How to Set up Run-time Functions","text":"You can also write data to other files that you define yourself.  For example, if you wanted to save the lift and drag coefficients in a .csv file for easy plotting later, you would simply open a file, write to it, and close it as one would normally do.","category":"page"},{"location":"how-to-guide/define-complex-systems/#How-to-Define-Vehicle-Systems","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"","category":"section"},{"location":"how-to-guide/define-complex-systems/","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"In this guide, we will cover how to define complex systems. Basic system definitions were presented in the First Steps tutorial, but applications quickly become more complex than a simple, control-free wing.","category":"page"},{"location":"how-to-guide/define-complex-systems/#Wing-Subsystems","page":"How to Define Vehicle Systems","title":"Wing Subsystems","text":"","category":"section"},{"location":"how-to-guide/define-complex-systems/","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"We will first cover creating wing subsystems.  The key here is that any system can be a sub-system. Take, for example, the vertical stabilizer and rudder from How to define Complex Wings which we can define a add to a wing system.","category":"page"},{"location":"how-to-guide/define-complex-systems/","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"#Vertical Stabilizer\nspan = 0.25                                     #length of full span\nnumlattice = 5                                  #number of lattice elements on half-span\nposchord = [0.0; 1.0]                #postion of chord stations\nlengthtipchordvstab = 0.05                          #length of tip chord\nlengthchordvstab = [1.25; 1.0]     #length of chords\ntwistchord = [0.0; 0.0]                         #twist of chords, in degrees\nsweepsection = [0.0]                      #sweep of sections between chords, in degrees\ndihedralsection = [0.0]                    #dihedral of sections between chords, in degrees\naspectratio = span/lengthtipchordvstab\n\nverticalstabilizer = vlm.complexWing(span, aspectratio, numlattice, poschord, lengthchordvstab, twistchord, sweepsection, dihedralsection; symmetric=false, chordalign=1.0)\n\noriginvstab = [0.5; 0.0; 0.0]                       #origin moved 0.5 in positive x-direction\ncsysvstab = [1.0 0.0 0.0; 0.0 0.0 1.0; 0.0 1.0 0.0] #csys rotated 90 degrees from default\nvlm.setcoordsystem(verticalstabilizer,originvstab,csysvstab)\n\n\n#Rudder\nspan = 0.25                                     #length of full span\nnumlattice = 5                                  #number of lattice elements on half-span\nposchord = [0.0; 0.25; 1.0]                #postion of chord stations\nlengthtipchord = 0.03                          #length of tip chord\nlengthchord = [1.25; 1.5; 1.0]     #length of chords\ntwistchord = [0.0; 0.0; 0.0]                         #twist of chords, in degrees\nsweepsection = [0.0; 0.0]                      #sweep of sections between chords, in degrees\ndihedralsection = [0.0; 0.0]                    #dihedral of sections between chords, in degrees\naspectratio = span/lengthtipchord\n\nrudder = vlm.complexWing(span, aspectratio, numlattice, poschord, lengthchord, twistchord, sweepsection, dihedralsection; symmetric=false, chordalign=0.0)\n\nlengthrootchordvstab = lengthchordvstab[1]*lengthtipchordvstab\noriginrudder = [0.5+lengthrootchordvstab; 0.0; 0.0]                       #account for vstab position and chord\ncsysrudder = [1.0 0.0 0.0; 0.0 0.0 1.0; 0.0 1.0 0.0] #csys rotated 90 degrees from default\nvlm.setcoordsystem(rudder,originrudder,csysrudder)\n\n\n#System Definition\ntail = vlm.WingSystem()\nvlm.addwing(tail,\"vstab\",verticalstabilizer)\nvlm.addwing(tail,\"rudder\",rudder)","category":"page"},{"location":"how-to-guide/define-complex-systems/","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"Now we might want that tail system to be part of a full system, so let's define the main wing and add both it and the tail system to the full system.","category":"page"},{"location":"how-to-guide/define-complex-systems/","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"#Main Wing\nspan = 1.0                      #length of full span\nnumlattice = 10                 #number of lattice elements on half-span\n\nposchord = [0.0; 0.5; 1.0]./span                #postion of chord stations\nlengthtipchord = 0.03                            #length of tip chord\nlengthchord = [0.075; 0.05; 0.03]./lengthtipchord   #length of chords\ntwistchord = [0.0; 0.0; -3.0]                   #twist of chords, in degrees\nsweepsection = [10.0; 5.0]      #sweep of sections between chords, in degrees\ndihedralsection = [0.0; 7.0]    #dihedral of sections between chords, in degrees\naspectratio = span/lengthtipchord\n\nmainwing = vlm.complexWing(span, aspectratio, numlattice, poschord, lengthchord, twistchord, sweepsection, dihedralsection; symmetric=true)\n\n\n#System Definition\nsystem = vlm.WingSystem()\nvlm.addwing(system,\"mainwing\",mainwing)\nvlm.addwing(system,\"tail\",tail)","category":"page"},{"location":"how-to-guide/define-complex-systems/","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"And that's all there is to it. The main wing and tail system are now both components of the overall system. Any combination of wing objects and wing systems can be added to any system.","category":"page"},{"location":"how-to-guide/define-complex-systems/#VLM-Systems","page":"How to Define Vehicle Systems","title":"VLM Systems","text":"","category":"section"},{"location":"how-to-guide/define-complex-systems/","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"Anything that will be solved using the VLM (see Reference) needs to be identified as such. In our case, all the wings fall under this category.","category":"page"},{"location":"how-to-guide/define-complex-systems/","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"vlm_system = vlm.WingSystem()\nvlm.addwing(vlm_system,\"mainwing\",mainwing)\nvlm.addwing(vlm_system,\"tail\",tail)","category":"page"},{"location":"how-to-guide/define-complex-systems/#Wake-Systems","page":"How to Define Vehicle Systems","title":"Wake Systems","text":"","category":"section"},{"location":"how-to-guide/define-complex-systems/","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"You need to tell the solver which of the systems you've created need to be included in the wake simulation.  In this case, we want everything to be in our wake system, which is defined just like before.","category":"page"},{"location":"how-to-guide/define-complex-systems/","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"wake_system = vlm.WingSystem()\nvlm.addwing(wake_system,\"mainwing\",mainwing)\nvlm.addwing(wake_system,\"tail\",tail)","category":"page"},{"location":"how-to-guide/define-complex-systems/#Rotor-Systems","page":"How to Define Vehicle Systems","title":"Rotor Systems","text":"","category":"section"},{"location":"how-to-guide/define-complex-systems/","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"Rotor systems begin with rotors, the definition of which is covered in How to Define a Custom Rotor.  Once you have rotors defined with their respetive databases, you can create rotor systems.  Let's add two rotors to our airplane in this guide to see how it is done.","category":"page"},{"location":"how-to-guide/define-complex-systems/","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"First let's decide where we want to place the rotors.","category":"page"},{"location":"how-to-guide/define-complex-systems/","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"posrotorplus = [0.0; 0.25; 0.0]      #xyz position of rotor in positive y-direction\nposrotorminus = -posrotorplus       #xyz position of rotor in negative y-direction\nvehicleaxis = [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0]   #default coordinate system","category":"page"},{"location":"how-to-guide/define-complex-systems/","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"We need a few more parameters for defining rotors as well.","category":"page"},{"location":"how-to-guide/define-complex-systems/","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"rotor_file = \"apc10x7.csv\"          # data file for rotor\ndata_path = uns.def_data_path       # data path to find file\n\nR, B = uns.read_rotor(rotor_file; data_path=data_path)[[1,3]] #grab rotor radius\nn = 100.0                           #target RPS\nVref = 20.0                         #freestream velocity\nvind = sqrt( Vref^2 + (n*R)^2 )     #velocity at blade tip\nrho = 1.225                         #(kg/m^3) air density\nmu = 1.81e-5                        #(kg/ms) air dynamic viscosity\nReD = rho*2.0*R*vind/mu             #Diameter-based Reynolds\n\nnumbladeelements = 10               #number of blade elements\nrotorpitch = 0.0                    #rotor pitch","category":"page"},{"location":"how-to-guide/define-complex-systems/","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"Now we are ready to define some propellers.","category":"page"},{"location":"how-to-guide/define-complex-systems/","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"rotors = vlm.Rotor[]\n\npush!(rotors,\n        uns.generate_rotor(rotor_file;\n                            pitch=rotorpitch,\n                            n=numbladeelements,\n                            CW=true,\n                            ReD=ReD,\n                            verbose=true,\n                            xfoil=false,\n                            data_path=data_path)\n    )\n\n\npush!(rotors,\n        vlm.Rotor(!rotors[1].CW,\n                    rotors[1].r,\n                    rotors[1].chord,\n                    rotors[1].theta,\n                    rotors[1].LE_x,\n                    rotors[1].LE_z,\n                    rotors[1].B,\n                    rotors[1].airfoils))\n\nvlm.initialize(rotors[2], rotors[1].m)\n\nvlm.setcoordsystem(rotors[1], posrotorminus, vehicleaxis; user=true)\nvlm.setcoordsystem(rotors[2], posrotorplus, vehicleaxis; user=true)","category":"page"},{"location":"how-to-guide/define-complex-systems/","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"Now that we have defined our rotors, we can add them to the other systems","category":"page"},{"location":"how-to-guide/define-complex-systems/","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"for (i, rotor) in enumerate(rotors)\n    vlm.addwing(system, \"rotor$i\", rotor)\n    vlm.addwing(wake_system, \"Rotor$i\", rotor)\nend","category":"page"},{"location":"how-to-guide/define-complex-systems/","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"note: Repeated Object Names\nYou can only use a specific name in one system. Note how in the example above, rotor$i is used for the main system, and captial Rotor$i is used for the wake system","category":"page"},{"location":"how-to-guide/define-complex-systems/","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"Finally, we need to create our rotor system, which is actually just a tuple of the rotor object we've already created.","category":"page"},{"location":"how-to-guide/define-complex-systems/","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"rotor_systems = (rotors, )","category":"page"},{"location":"how-to-guide/define-complex-systems/","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"(Image: )","category":"page"},{"location":"how-to-guide/define-complex-systems/#Tilting-Systems","page":"How to Define Vehicle Systems","title":"Tilting Systems","text":"","category":"section"},{"location":"how-to-guide/define-complex-systems/","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"A tilting system is simply a tuple of all the wing systems that will be rotating according to specific definitions beyond the overall aircraft orientations. In our case, that would just be the rudder.","category":"page"},{"location":"how-to-guide/define-complex-systems/","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"tilting_systems = (rudder, )","category":"page"},{"location":"how-to-guide/define-complex-systems/","page":"How to Define Vehicle Systems","title":"How to Define Vehicle Systems","text":"#Vertical Stabilizer\nspan = 0.25                                     #length of full span\nnumlattice = 5                                  #number of lattice elements on half-span\nposchord = [0.0; 1.0]                #postion of chord stations\nlengthtipchordvstab = 0.05                          #length of tip chord\nlengthchordvstab = [1.25; 1.0]     #length of chords\ntwistchord = [0.0; 0.0]                         #twist of chords, in degrees\nsweepsection = [0.0]                      #sweep of sections between chords, in degrees\ndihedralsection = [0.0]                    #dihedral of sections between chords, in degrees\naspectratio = span/lengthtipchordvstab\n\nverticalstabilizer = vlm.complexWing(span, aspectratio, numlattice, poschord, lengthchordvstab, twistchord, sweepsection, dihedralsection; symmetric=false, chordalign=1.0)\n\noriginvstab = [0.5; 0.0; 0.0]                       #origin moved 0.5 in positive x-direction\ncsysvstab = [1.0 0.0 0.0; 0.0 0.0 1.0; 0.0 1.0 0.0] #csys rotated 90 degrees from default\nvlm.setcoordsystem(verticalstabilizer,originvstab,csysvstab)\n\n\n#Rudder\nspan = 0.25                                     #length of full span\nnumlattice = 5                                  #number of lattice elements on half-span\nposchord = [0.0; 0.25; 1.0]                #postion of chord stations\nlengthtipchord = 0.03                          #length of tip chord\nlengthchord = [1.25; 1.5; 1.0]     #length of chords\ntwistchord = [0.0; 0.0; 0.0]                         #twist of chords, in degrees\nsweepsection = [0.0; 0.0]                      #sweep of sections between chords, in degrees\ndihedralsection = [0.0; 0.0]                    #dihedral of sections between chords, in degrees\naspectratio = span/lengthtipchord\n\nrudder = vlm.complexWing(span, aspectratio, numlattice, poschord, lengthchord, twistchord, sweepsection, dihedralsection; symmetric=false, chordalign=0.0)\n\nlengthrootchordvstab = lengthchordvstab[1]*lengthtipchordvstab\noriginrudder = [0.5+lengthrootchordvstab; 0.0; 0.0]                       #account for vstab position and chord\ncsysrudder = [1.0 0.0 0.0; 0.0 0.0 1.0; 0.0 1.0 0.0] #csys rotated 90 degrees from default\nvlm.setcoordsystem(rudder,originrudder,csysrudder)\n\n\n#System Definition\ntail = vlm.WingSystem()\nvlm.addwing(tail,\"vstab\",verticalstabilizer)\nvlm.addwing(tail,\"rudder\",rudder)\n\n#Main Wing\nspan = 1.0                      #length of full span\nnumlattice = 10                 #number of lattice elements on half-span\n\nposchord = [0.0; 0.5; 1.0]./span                #postion of chord stations\nlengthtipchord = 0.03                            #length of tip chord\nlengthchord = [0.075; 0.05; 0.03]./lengthtipchord   #length of chords\ntwistchord = [0.0; 0.0; -3.0]                   #twist of chords, in degrees\nsweepsection = [10.0; 5.0]      #sweep of sections between chords, in degrees\ndihedralsection = [0.0; 7.0]    #dihedral of sections between chords, in degrees\naspectratio = span/lengthtipchord\n\nmainwing = vlm.complexWing(span, aspectratio, numlattice, poschord, lengthchord, twistchord, sweepsection, dihedralsection; symmetric=true)\n\n\n#System Definition\nsystem = vlm.WingSystem()\nvlm.addwing(system,\"mainwing\",mainwing)\nvlm.addwing(system,\"tail\",tail)\n\n\n\n\nposrotorplus = [0.0; 0.25; 0.0]      #xyz position of rotor in positive y-direction\nposrotorminus = -posrotorplus       #xyz position of rotor in negative y-direction\nvehicleaxis = [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0]   #default coordinate system\n\n\n\n\nrotor_file = \"apc10x7.csv\"          # data file for rotor\ndata_path = uns.def_data_path       # data path to find file\n\nR, B = uns.read_rotor(rotor_file; data_path=data_path)[[1,3]] #grab rotor radius\nn = 100.0                           #target RPS\nVref = 20.0                         #freestream velocity\nvind = sqrt( Vref^2 + (n*R)^2 )     #velocity at blade tip\nrho = 1.225                         #(kg/m^3) air density\nmu = 1.81e-5                        #(kg/ms) air dynamic viscosity\nReD = rho*2.0*R*vind/mu             #Diameter-based Reynolds\n\nnumbladeelements = 10               #number of blade elements\nrotorpitch = 0.0                    #rotor pitch\n\n\nrotors = vlm.Rotor[]\n\npush!(rotors,\n        uns.generate_rotor(rotor_file;\n                            pitch=rotorpitch,\n                            n=numbladeelements,\n                            CW=true,\n                            ReD=ReD,\n                            verbose=true,\n                            xfoil=false,\n                            data_path=data_path)\n    )\n\n\npush!(rotors,\n        vlm.Rotor(!rotors[1].CW,\n                    rotors[1].r,\n                    rotors[1].chord,\n                    rotors[1].theta,\n                    rotors[1].LE_x,\n                    rotors[1].LE_z,\n                    rotors[1].B,\n                    rotors[1].airfoils))\n\nvlm.initialize(rotors[2], rotors[1].m)\n\nvlm.setcoordsystem(rotors[1], posrotorminus, vehicleaxis; user=true)\nvlm.setcoordsystem(rotors[2], posrotorplus, vehicleaxis; user=true)\n\n\n\nfor (i, rotor) in enumerate(rotors)\n    vlm.addwing(wake_system, \"rotor$i\", rotor)\nend\n\n\n\n\nVinf(x,t) = [1,0,0]         #non-dimensional function defining free stream velocity\nvlm.setVinf(system, Vinf)   #set freestream velocity for the system\nRPMref = 6000       #reference RPM\nfor rotor in rotors; vlm.setRPM(rotor, RPMref); end;\n\nrun_name = \"tutorial\"           #define identifier at beginning of file names\nsave_path = \"./simplewing/\"     #define directory where files will be saved\n\nrun(`rm -rf $save_path`)        #clear out directory where files will be saved\nrun(`mkdir $save_path`)         #re-create directory fresh\n\nvlm.save(system, run_name; path=save_path)  #save geometry in a .vtk file format\nrun(`paraview`)","category":"page"},{"location":"tutorials/getting-started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"tutorials/getting-started/","page":"Getting Started","title":"Getting Started","text":"In order to install FLOWUnsteady.jl, first set Julia up in your system (download from https://julialang.org/downloads/), and take care of the dependencies listed here below.","category":"page"},{"location":"tutorials/getting-started/","page":"Getting Started","title":"Getting Started","text":"note: Julia version\nFLOWUnsteady has been developed and tested in Julia v1.4.2, hence we recommend using this version.","category":"page"},{"location":"tutorials/getting-started/#Setting-up-PyCall","page":"Getting Started","title":"Setting up PyCall","text":"","category":"section"},{"location":"tutorials/getting-started/","page":"Getting Started","title":"Getting Started","text":"The 'airfoilprep.py' package (wrapped by the 'AirfoilPrep.jl' package) is written in Python 2.7, so make sure that the Python version linked to PyCall.jl is 2.7. You can do this by running the following:","category":"page"},{"location":"tutorials/getting-started/","page":"Getting Started","title":"Getting Started","text":"import Pkg\nPkg.add(\"PyCall\")\nENV[\"PYTHON\"] = \"path/to/your/python2\"\nPkg.build(\"PyCall\")","category":"page"},{"location":"tutorials/getting-started/","page":"Getting Started","title":"Getting Started","text":"Then close and reopen the Julia REPL, and run:","category":"page"},{"location":"tutorials/getting-started/","page":"Getting Started","title":"Getting Started","text":"import PyCall\nPyCall.pyversion","category":"page"},{"location":"tutorials/getting-started/","page":"Getting Started","title":"Getting Started","text":"which should reveal your Python version:","category":"page"},{"location":"tutorials/getting-started/","page":"Getting Started","title":"Getting Started","text":"v\"2.7.16\"","category":"page"},{"location":"tutorials/getting-started/#Paraview","page":"Getting Started","title":"Paraview","text":"","category":"section"},{"location":"tutorials/getting-started/","page":"Getting Started","title":"Getting Started","text":"To visualize your simulations, we need to install the open-source visualization engine Paraview, which may be downloaded for free here. Any version will work well.","category":"page"},{"location":"tutorials/getting-started/","page":"Getting Started","title":"Getting Started","text":"Some of the examples call Paraview through the Julia command run(\\paraview`), which is equivalent to calling Paraview from the terminal by typingparaview. In order to be able to call Paraview throughparaview, if you are using a Linux distribution, you will add the Paraview binary to the user-levelbin` folder through a symbolic link:","category":"page"},{"location":"tutorials/getting-started/","page":"Getting Started","title":"Getting Started","text":"sudo ln -s /path/to/your/paraview /usr/local/bin/paraview","category":"page"},{"location":"tutorials/getting-started/","page":"Getting Started","title":"Getting Started","text":"If you're using MacOS, you will need to export the folder with your Paraview executable to your path by running:","category":"page"},{"location":"tutorials/getting-started/","page":"Getting Started","title":"Getting Started","text":"export PATH=$PATH:/path/to/your/paraview/","category":"page"},{"location":"tutorials/getting-started/","page":"Getting Started","title":"Getting Started","text":"where your path likely looks like /Applications/ParaView-5.5.2.app/Contents/MacOS/ (substituting 5.5.2 for your version number).","category":"page"},{"location":"tutorials/getting-started/","page":"Getting Started","title":"Getting Started","text":"To test if Paraview is working well, you can pull up one of the examples under 'examples/' in the GeometricTools repo:","category":"page"},{"location":"tutorials/getting-started/","page":"Getting Started","title":"Getting Started","text":"# Import Package\nimport Pkg\n] add https://github.com/byuflowlab/GeometricTools.jl.git # type the `]` key to enter the package manager and add the GeometricTools Rep\nimport GeometricTools\ngt = GeometricTools\n\n# Load example\nexamplepath = joinpath(pathof(GeometricTools)[1:end-length(\"GeometricTools.jl\")],\"../examples/example_simple.jl\")\ninclude(examplepath)\n\n# Run example: it will pull up paraview with a good-looking cube\nsimple_box2()","category":"page"},{"location":"tutorials/getting-started/","page":"Getting Started","title":"Getting Started","text":"Paraview should open a rendering of a cube. You'll have to click the \"eye\" icon in the file tree next to temp_vtk_example.vtk to make it visible.","category":"page"},{"location":"tutorials/getting-started/","page":"Getting Started","title":"Getting Started","text":"(Image: Img)","category":"page"},{"location":"tutorials/getting-started/#FLOW's-Unregistered-Dependencies","page":"Getting Started","title":"FLOW's Unregistered Dependencies","text":"","category":"section"},{"location":"tutorials/getting-started/","page":"Getting Started","title":"Getting Started","text":"The following dependencies are unregistered Julia packages that need to be added manually through the command ] add github-url-to-the-package in the Julia REPL.","category":"page"},{"location":"tutorials/getting-started/","page":"Getting Started","title":"Getting Started","text":"GeometricTools: github.com/byuflowlab/GeometricTools.jl\nAirfoilPrep: github.com/byuflowlab/AirfoilPrep.jl\nFLOWVLM: github.com/byuflowlab/FLOWVLM\nBPM: github.com/byuflowlab/BPM.jl\nFLOWNoise: github.com/byuflowlab/FLOWNoise\nMyVPM: Contact Ed Alvarez (edoalvarez.com) or the FLOW Lab (flow.byu.edu).\n(Optional) MyPanel: github.com/EdoAlvarezR/MyPanel.jl","category":"page"},{"location":"tutorials/getting-started/#Install-FLOWUnsteady","page":"Getting Started","title":"Install FLOWUnsteady","text":"","category":"section"},{"location":"tutorials/getting-started/","page":"Getting Started","title":"Getting Started","text":"Now you are ready to install the FLOWUnsteady package through the following command in the Julia REPL: ] add https://github.com/byuflowlab/FLOWUnsteady.","category":"page"},{"location":"tutorials/getting-started/#Setup-Troubleshooting","page":"Getting Started","title":"Setup Troubleshooting","text":"","category":"section"},{"location":"tutorials/getting-started/","page":"Getting Started","title":"Getting Started","text":"Some things you might need to look out for:","category":"page"},{"location":"tutorials/getting-started/","page":"Getting Started","title":"Getting Started","text":"Make sure your Homebrew (in Julia) is up to date. You may need to run the following:","category":"page"},{"location":"tutorials/getting-started/","page":"Getting Started","title":"Getting Started","text":"using Homebrew\nHomebrew.brew(`update-reset`)","category":"page"},{"location":"tutorials/getting-started/","page":"Getting Started","title":"Getting Started","text":"in order to update your Homebrew.","category":"page"},{"location":"tutorials/getting-started/","page":"Getting Started","title":"Getting Started","text":"You're going to have to make sure that things are in place in your Julia settings. Having things like Conda, HDF5, etc. on your machine doesn't necessarily mean that the Julia implementation has them as well.\nIf you don't have a fortran compiler, Xfoil (one of the dependencies of AirfoilPrep) won't compile.  On MacOS, try brew install gcc\nThe AirfoilPrep compiler creates symbolic links. Right now, symbolic links do not work if you're trying to create them in Box, it won't work, you'll get the following error:","category":"page"},{"location":"tutorials/getting-started/","page":"Getting Started","title":"Getting Started","text":"Linux - Gfortran\nrm -f common.mk\nln -s ./config/config.LINUX_GFORTRAN.mk common.mk\nln: common.mk: Function not implemented\nmake: *** [gfortran] Error 1","category":"page"},{"location":"tutorials/getting-started/","page":"Getting Started","title":"Getting Started","text":"So don't put AirfoilPrep in Box.","category":"page"},{"location":"tutorials/getting-started/#Running-The-Examples","page":"Getting Started","title":"Running The Examples","text":"","category":"section"},{"location":"tutorials/getting-started/","page":"Getting Started","title":"Getting Started","text":"In order to test that all FLOWUnsteady and all dependencies were successfully installed, try running some of the examples under FLOWUnsteady/examples/ (the outputs of some of the examples are shown in this notebook: docs/resources/examples.ipynb).","category":"page"},{"location":"tutorials/getting-started/","page":"Getting Started","title":"Getting Started","text":"For instance, you can run the tandem heaving wing example, through the following commands in the Julia REPL:","category":"page"},{"location":"tutorials/getting-started/","page":"Getting Started","title":"Getting Started","text":"\nimport FLOWUnsteady\n\n# Path to examples folder\npath_to_examples = joinpath(dirname(pathof(FLOWUnsteady)), \"..\", \"examples\")\n\n# Include tandem heaving wing example\ninclude(joinpath(path_to_examples, \"tandemheavingwing.jl\"))\n\n# Include tandem heaving wing example\ninclude(joinpath(path_to_examples, \"tandemheavingwing.jl\"))\n\n# Run tandem heaving wing example\ntandemheavingwing(; VehicleType=uns.UVLMVehicle,\n                    save_path=\"tandemheaving-example/\");\n\n# OPTIONAL: Call Paraview for visualization\nvtk_files = \"tandemheaving-example/bertins_Main_vlm...vtk;bertins_Tilting_Tandem_vlm...vtk;bertins_pfield...vtk;\"\nrun(`paraview --data=$(vtk_files)`)","category":"page"},{"location":"tutorials/getting-started/","page":"Getting Started","title":"Getting Started","text":"This will pull up Paraview showing the computed geometry and time steps. Sit back, press play, and enjoy the simulation that you have just run (it should look like the video shown below). (Image: Vid here)","category":"page"},{"location":"how-to-guide/wake-stability/#How-to-Approach-Wake-Stability-Issues","page":"How to Approach Wake Stability Issues","title":"How to Approach Wake Stability Issues","text":"","category":"section"},{"location":"how-to-guide/wake-stability/","page":"How to Approach Wake Stability Issues","title":"How to Approach Wake Stability Issues","text":"The vortex particle method does pretty well until a wake reaches turbulent breakdown, at which point the solver can become unstable.  There are several ways to try to maintain stability.  Some include inherent object physics, others have to do with simulation parameters, and others involve removing particles from the simulation.  The following are some things that the users have encountered and found helpful.","category":"page"},{"location":"how-to-guide/wake-stability/#Inherent-Physics","page":"How to Approach Wake Stability Issues","title":"Inherent Physics","text":"","category":"section"},{"location":"how-to-guide/wake-stability/","page":"How to Approach Wake Stability Issues","title":"How to Approach Wake Stability Issues","text":"The inherent physics of the problem may lead to turbulent breakdown happening sooner or later.  For example, there is a direct relationship between number of rotor blades and when breakdown happens.  The more blades there are, the sooner breakdown will occur.  In addition, the higher the tipspeed ratio, the sooner breakdown will occur.  Some instances of turbulent breakdown are therefore unavoidable, and the user should be aware of this limitation.","category":"page"},{"location":"how-to-guide/wake-stability/#Simulation-Parameters","page":"How to Approach Wake Stability Issues","title":"Simulation Parameters","text":"","category":"section"},{"location":"how-to-guide/wake-stability/","page":"How to Approach Wake Stability Issues","title":"How to Approach Wake Stability Issues","text":"Sometimes, changing the simulation parameters can help keep things numerically stable for longer.  For example, the resoultion of the simulation, that is, the number and spacing of the horseshoes and particles can affect stability.","category":"page"},{"location":"how-to-guide/wake-stability/","page":"How to Approach Wake Stability Issues","title":"How to Approach Wake Stability Issues","text":"In addition, there are some relaxation parameters available in the various solvers that can improve or worsen stability.  Referring to the reference section of this documentation will reveal what parameters there are and what they are for. Some of the papers cited in the Theory section also indicate some recommended parameters.","category":"page"},{"location":"how-to-guide/wake-stability/#Wake-Trimming","page":"How to Approach Wake Stability Issues","title":"Wake Trimming","text":"","category":"section"},{"location":"how-to-guide/wake-stability/","page":"How to Approach Wake Stability Issues","title":"How to Approach Wake Stability Issues","text":"One method to maintain stability is to remove some of the wake particles.  This is done using an extra runtime function described in How to Set up Run-time Functions.","category":"page"},{"location":"how-to-guide/wake-stability/","page":"How to Approach Wake Stability Issues","title":"How to Approach Wake Stability Issues","text":"Let's say you wanted to remove the particles after a certain point behind your vehicle. One way you could do this is to obtain the location of an object in your system, let's say a rotor, and then delete the particles behind a certain point relative to that location.","category":"page"},{"location":"how-to-guide/wake-stability/","page":"How to Approach Wake Stability Issues","title":"How to Approach Wake Stability Issues","text":"rotors = vcat(sim.vehicle.rotor_systems...) #get rotors from simulation\norigin = rotors[1]._wingsystem.O            #choose an object origin\nrefxaxis = rotors[1]._wingsystem.Oaxis[1,:] #get the origin axis\n\n#loop through all the particles and delete if behind cuttoff point\nfor i in vpm.get_np(pfield):-1:1\n    particleposition = vpm.get_x(pfield, i) #obtain particle absolute position\n    particlevector = particlepostition - origin #obtain particle vector relative to origin\n\n    #delete if dinstance from orgin in x-direction is greater than cutoff\n    if abs(dot(particlevector,refxaxis)) > cutoffcriteria\n        vpm.delparticle(pfield, i)\n    end\nend","category":"page"},{"location":"how-to-guide/wake-stability/","page":"How to Approach Wake Stability Issues","title":"How to Approach Wake Stability Issues","text":"You could also just remove everything a certain distance from your origin of choice, which would take everything other than a sphere around that object.","category":"page"},{"location":"how-to-guide/wake-stability/","page":"How to Approach Wake Stability Issues","title":"How to Approach Wake Stability Issues","text":"Furthermore, you can define more advanced cutoff criteria, but special consideration may be in order.  For example, some systems rotate (like rotors and tilting systems) so their coordinate systems also rotate in time.  So if you wanted to delete particles outside a certain boundary from a rotor, you could do so for a cylindrical boundary.","category":"page"},{"location":"how-to-guide/wake-stability/","page":"How to Approach Wake Stability Issues","title":"How to Approach Wake Stability Issues","text":"refyaxis = rotors[1]._wingsystem.Oaxis[2, :] # reference y axis\nrefzaxis = rotors[1]._wingsystem.Oaxis[3, :] # reference z axis\n\n#calculate the radial position of the particle\nradialpos = (sqrt(dot(parvec,refyaxis)^2 + dot(parvec,refzaxis)^2)","category":"page"},{"location":"how-to-guide/wake-stability/","page":"How to Approach Wake Stability Issues","title":"How to Approach Wake Stability Issues","text":"The Reference section of this documentation will cover all the fields in the wing system objects available to the user. How they are used, and what cutoff criteria in needed depends on the specific use and the user's desires.","category":"page"},{"location":"theory/FLOWVLMtheory/#FLOWVLM","page":"FLOWVLM","title":"FLOWVLM","text":"","category":"section"},{"location":"theory/FLOWVLMtheory/","page":"FLOWVLM","title":"FLOWVLM","text":"FLOWVLM is a vortex lattice method (VLM) code for solving aerodynamics, but is far more than that. FLOWVLM has a general three-dimensional geometric engine that powers much of the geometry of FLOWUnsteady and is also the foundation of the blade-element rotor solver. In this section we describe how wing geometries are defined, how multiple wings can be grouped into a wing system, and how objects can be rotated and translated in space.","category":"page"},{"location":"theory/FLOWVLMtheory/#Wing-Definition","page":"FLOWVLM","title":"Wing Definition","text":"","category":"section"},{"location":"theory/FLOWVLMtheory/","page":"FLOWVLM","title":"FLOWVLM","text":"A FLOWVLM.Wing object is simply a data structure that encapsulates a collection of horseshoes vortices (or a vortex lattice). A horseshoe vortex is made out of one bound vortex located at the quarter-chord position, two trailing bound vortices going back to the trailing edge, and two semi-infinite vortices extending from the trailing edge out in the direction of the freestream, as shown below.","category":"page"},{"location":"theory/FLOWVLMtheory/","page":"FLOWVLM","title":"FLOWVLM","text":"<img src=\"../assets/theoryfigs/horseshoe00.png\" alt=\"drawing\" width=\"400\" />","category":"page"},{"location":"theory/FLOWVLMtheory/","page":"FLOWVLM","title":"FLOWVLM","text":"A control point is associated to every horseshoe, which is located at the three-quarter chord position. At this point, the no-flow-through boundary condition is imposed, canceling the component of the freestream that is normal to the surface.","category":"page"},{"location":"theory/FLOWVLMtheory/","page":"FLOWVLM","title":"FLOWVLM","text":"note: Unsteady wake\nIn the unsteady solver of FLOWUnsteady, semi-infinite trailing vortices of the horseshoes are replaced by vortex particles that are shed off the trailing edge at every time step.","category":"page"},{"location":"theory/FLOWVLMtheory/","page":"FLOWVLM","title":"FLOWVLM","text":"There are three ways of defining a VLM wing. The first one is to manually add chord stations along the wing and discretize the sections in between into horseshoes. This approach is tedious and is rarely used. The second one is through the function FLOWVLM.SimpleWing that takes the parameters of the root and tip of the wing and interpolates and discretizes everything in between, which works well for most conventional wings. Finally, for complex geometries (for instance, an asymmetric wing or a wing with winglets), the user can call FLOWVLM.ComplexWing that works pretty much like the option of manually building the wing but in a friendlier way.","category":"page"},{"location":"theory/FLOWVLMtheory/#Manually-Building-the-Wing","page":"FLOWVLM","title":"Manually Building the Wing","text":"","category":"section"},{"location":"theory/FLOWVLMtheory/","page":"FLOWVLM","title":"FLOWVLM","text":"You can build a wing by adding each chord station manually and indicating the discretization in between.   This is done by indicating the leading edge position and chord length at each station, and the number of horseshoes in between stations.   This approach uses the FLOWVLM.Wing constructor to initialize the wing and the FLOWVLM.addwing function to add each chord.","category":"page"},{"location":"theory/FLOWVLMtheory/","page":"FLOWVLM","title":"FLOWVLM","text":"FLOWVLM.Wing","category":"page"},{"location":"theory/FLOWVLMtheory/","page":"FLOWVLM","title":"FLOWVLM","text":"FLOWVLM.addchord","category":"page"},{"location":"theory/FLOWVLMtheory/#FLOWVLM.addchord","page":"FLOWVLM","title":"FLOWVLM.addchord","text":"addchord(wing, x, y, z, c, twist, n, r=1.0)\n\nAdds a new chord to the wing and creates n lattices in the new section. Wing must be build from left to right.\n\nArguments\n\nx       : x-position leading edge of the chord.\ny       : y-position of the chord.\nz       : z-position leading edge of the chord.\nc       : Chord length.\ntwist   : Twist of the chord in degrees.\nn::Int64: Number of lattices in the new section.\n\nOptional arguments\n\nr       : Ratio between lengths of first and last lattices.\ncentral : Give it true to take the length ratio between the lattice\n          midway and first and last. Give it a number between 0 and 1\n          to define the position of the reference midway.\nrefinement : Use this option for more complex refinements. It\n          receives an array `[sec1, sec2, ...]` with sections of\n          refinements in the format `sec=[c, n, r]`, with `c` the length\n          of this section (sum of all c = 1), `n` the ratio of lattices\n          in this section, and `r` the increment ratio. If this option\n          is used, it will ignore arguments `r` and `central`.\n\nExamples\n\n`julia> wing = Wing(0.0, 0.0, 0.0, 10.0, 3.0);`\n`julia> addchord(wing, 2.5, 10.0, 5.0, 5.0, 0.0, 10);`\n\n\n\n\n\n","category":"function"},{"location":"theory/FLOWVLMtheory/","page":"FLOWVLM","title":"FLOWVLM","text":"This requires the user to do all the calculations of what the geometry should look like based on the desired aspect ratio, taper ratio, etc.   In the following line we are doing such calculations for a 40^circ-swept-back wing with an aspect ratio of 5.0.","category":"page"},{"location":"theory/FLOWVLMtheory/","page":"FLOWVLM","title":"FLOWVLM","text":"  # Wing parameters\n  b = 98*0.0254                   # (m) span\n  ar = 5.0                        # Aspect ratio (span over tip chord)\n  tr = 1.0                        # Taper ratio\n  lambda = 45.0                   # (deg) sweep\n  gamma = 0.0                     # (deg) dihedral\n  twist_tip = 0.0                 # (deg) tip twist\n  twist_root = 0.0                # (deg) root twist\n  n = 4                           # Horseshoes in between chord stations\n\n  # Calculations\n  cr = 1/tr                       # Chord ratio (inverse of taper ratio)\n  c_tip = b/ar                    # Chord at tip\n  c_root = cr*c_tip               # Chord at root\n  y_tip = b/2                     # y-position of tip leading edge\n  x_tip = y_tip*tan(lambda*pi/180)# x-position of tip leading edge\n  z_tip = y_tip*tan(gamma*pi/180) # z-position of tip leading edge","category":"page"},{"location":"theory/FLOWVLMtheory/","page":"FLOWVLM","title":"FLOWVLM","text":"We initialize the wing by giving it the first chord station, which corresponds to the left chord.","category":"page"},{"location":"theory/FLOWVLMtheory/","page":"FLOWVLM","title":"FLOWVLM","text":"import FLOWVLM\n\n# Initialize the wing with the left tip chord\nwing = FLOWVLM.Wing(x_tip, -y_tip, z_tip, c_tip, twist_tip)","category":"page"},{"location":"theory/FLOWVLMtheory/","page":"FLOWVLM","title":"FLOWVLM","text":"Then we go on to add the root and the right tip chord.","category":"page"},{"location":"theory/FLOWVLMtheory/","page":"FLOWVLM","title":"FLOWVLM","text":"  # Add the root chord\n  FLOWVLM.addchord(wing, 0.0, 0.0, 0.0, c_root, twist_root, n)\n\n  # Add the right tip chord\n  FLOWVLM.addchord(wing, x_tip, y_tip, z_tip, c_tip, twist_tip, n)","category":"page"},{"location":"theory/FLOWVLMtheory/","page":"FLOWVLM","title":"FLOWVLM","text":"Notice that we placed the root at the (0, 0, 0) position.   This doesn't always have to be this way, but remember to move the other chord stations accordingly if you want to place the nose somewhere else.","category":"page"},{"location":"theory/FLOWVLMtheory/","page":"FLOWVLM","title":"FLOWVLM","text":"tip: Build wings from left to right\nIt is recommended that wings are build from left to right, or from -y to +y. Otherwise, the normals of the surface will point down in the negative z-direction and the circulation of the wing will be negative when generating upwards lift (positive z-direction). This is not a problem for the solver, but could be difficult to wrap your head around a negative circulation being associated to a positive lift.","category":"page"},{"location":"theory/FLOWVLMtheory/#SimpleWing","page":"FLOWVLM","title":"SimpleWing","text":"","category":"section"},{"location":"theory/FLOWVLMtheory/","page":"FLOWVLM","title":"FLOWVLM","text":"asdasd","category":"page"},{"location":"theory/FLOWVLMtheory/#ComplexWing","page":"FLOWVLM","title":"ComplexWing","text":"","category":"section"},{"location":"tutorials/aeroacoustics/#Aeroacoustic-Noise-Analysis","page":"Aeroacoustic Noise Analysis","title":"Aeroacoustic Noise Analysis","text":"","category":"section"},{"location":"tutorials/aeroacoustics/","page":"Aeroacoustic Noise Analysis","title":"Aeroacoustic Noise Analysis","text":"FLOWUnsteady uses PSU-WOPWOP (a FW-H code) and a BPM code for calculating tonal and broadband aeroacoustic noise, respectively. PSU-WOPWOP is not included in the FLOWUnsteady suite, but rather the user can request a binary of PSU-WOPWOP directly from the developer at Penn State University.","category":"page"},{"location":"tutorials/aeroacoustics/","page":"Aeroacoustic Noise Analysis","title":"Aeroacoustic Noise Analysis","text":"The example under examples/rotornoise/singlerotor.ipynb shows instructions and validation of the aeroacoustics solver. Further validation of rotor-on-rotor interactions is given in the following paper by the authors: Alvarez, E. J., Schenk, A., Critchfield, T., and Ning, A., “Rotor-on-Rotor Aeroacoustic Interactions of Multirotor in Hover,” Journal of the American Helicopter Society, Jul. 2020, (in review).","category":"page"},{"location":"tutorials/aeroacoustics/","page":"Aeroacoustic Noise Analysis","title":"Aeroacoustic Noise Analysis","text":"<img src=\"../../assets/vid/val_piv_multi16_005D_99_1_noise1_cropped00.gif\" alt=\"Vid\" width=\"400px\"/>","category":"page"},{"location":"tutorials/aeroacoustics/","page":"Aeroacoustic Noise Analysis","title":"Aeroacoustic Noise Analysis","text":"<img src=\"../../assets/vid/cfdnoise_ningdji_multi_005D_03_20.gif\" alt=\"Vid\" width=\"600px\"/>","category":"page"},{"location":"reference/VPMfunctions/#Functions-Contained-in-MyVPM","page":"Functions Contained in MyVPM","title":"Functions Contained in MyVPM","text":"","category":"section"},{"location":"reference/VPMfunctions/","page":"Functions Contained in MyVPM","title":"Functions Contained in MyVPM","text":"Modules = [MyVPM]\nOrder   = [:function, :type]","category":"page"},{"location":"reference/VPMfunctions/#MyVPM.ExaFMM_autotuning-Tuple{MyVPM.ParticleField}","page":"Functions Contained in MyVPM","title":"MyVPM.ExaFMM_autotuning","text":"Automatically tunes the paremeters of the FMM algorithm for optimum performance at the currrent number of particles in the field. WARNING: It has been observed that some of these parameters (specially theta)         bring instability into the VPM method.\n\n\n\n\n\n","category":"method"},{"location":"reference/VPMfunctions/#MyVPM.FDconv_ExaFMM-Tuple{MyVPM.ParticleField}","page":"Functions Contained in MyVPM","title":"MyVPM.FDconv_ExaFMM","text":"Calls ExaFMM to calculate induced velocity at every particle and corresponding convective term (convective term calculated through finite difference)\n\n\n\n\n\n","category":"method"},{"location":"reference/VPMfunctions/#MyVPM.K2-Tuple{Any,Any}","page":"Functions Contained in MyVPM","title":"MyVPM.K2","text":"Second regularization function found in Winckelmans and Leonard, 1993, Table 1\n\n\n\n\n\n","category":"method"},{"location":"reference/VPMfunctions/#MyVPM.U_ExaFMM-Tuple{Array{Float64,2},Int64}","page":"Functions Contained in MyVPM","title":"MyVPM.U_ExaFMM","text":"Calls ExaFMM to calculate induced velocity at every particle\n\n\n\n\n\n","category":"method"},{"location":"reference/VPMfunctions/#MyVPM.Uphi-Tuple{Any,Float64}","page":"Functions Contained in MyVPM","title":"MyVPM.Uphi","text":"Default velocity induced by the scalar-potential flow\n\n\n\n\n\n","category":"method"},{"location":"reference/VPMfunctions/#MyVPM._Utot-Tuple{MyVPM.ParticleField,Any,Any}","page":"Functions Contained in MyVPM","title":"MyVPM._Utot","text":"Total velocity at position X at the current time with the requested kernel.\n\n\n\n\n\n","category":"method"},{"location":"reference/VPMfunctions/#MyVPM._fetch-Tuple{MyVPM.ParticleField,Int64,Array{Int64,1}}","page":"Functions Contained in MyVPM","title":"MyVPM._fetch","text":"Returns the vector X containing the data requested in to_fetch from the n-th particle, where X[i] = self._p_field[to_fetch[i]].\n\nArguments\n\nto_fetch contains the indexes of the data to fetch as defined in the data structure definition block at the begining of this module.\n\nExamples\n\njulia> _fetch(p_field, 10, [_xi, _y_i, _zi])\nReturns current position of the 10th particle\n\n\n\n\n\n","category":"method"},{"location":"reference/VPMfunctions/#MyVPM._nextstep_euler-Tuple{MyVPM.ParticleField,Float64}","page":"Functions Contained in MyVPM","title":"MyVPM._nextstep_euler","text":"Steps the field forward in time by dt in a first-order Euler integration scheme.\n\n\n\n\n\n","category":"method"},{"location":"reference/VPMfunctions/#MyVPM._nextstep_rk-Tuple{MyVPM.ParticleField,Float64}","page":"Functions Contained in MyVPM","title":"MyVPM._nextstep_rk","text":"Steps the field forward in time by dt in a third-order low-storage Runge-Kutta integration scheme. See Notebook entry 20180105.\n\n\n\n\n\n","category":"method"},{"location":"reference/VPMfunctions/#MyVPM._update-Tuple{MyVPM.ParticleField,Any,Any,Array{Int64,1}}","page":"Functions Contained in MyVPM","title":"MyVPM._update","text":"Updates the current data of the n-th particle with X as self._p_field[n, index[i]] = X[i]\n\n\n\n\n\n","category":"method"},{"location":"reference/VPMfunctions/#MyVPM._update_Gamma-Tuple{MyVPM.ParticleField,Int64,Array{Float64,1}}","page":"Functions Contained in MyVPM","title":"MyVPM._update_Gamma","text":"Updates the current vectorial vorticity of the n-th particle\n\n\n\n\n\n","category":"method"},{"location":"reference/VPMfunctions/#MyVPM._update_x-Tuple{MyVPM.ParticleField,Int64,Any}","page":"Functions Contained in MyVPM","title":"MyVPM._update_x","text":"Updates the current position vector of the n-th particle\n\n\n\n\n\n","category":"method"},{"location":"reference/VPMfunctions/#MyVPM.addparticle-Tuple{MyVPM.ParticleField,Array{Float64,1}}","page":"Functions Contained in MyVPM","title":"MyVPM.addparticle","text":"`addparticle(self, particle)`\n\nAdds a particle to the field, where particle must follow the data structure defined at the begining of this module.\n\nExamples\n\njulia> addparticle(p_field, [x, y, z, gamma_x, gamma_y, gamma_z, sigma, vol])\n\n\n\n\n\n","category":"method"},{"location":"reference/VPMfunctions/#MyVPM.callExaFMM-Tuple{Array{Float64,2},Int64}","page":"Functions Contained in MyVPM","title":"MyVPM.callExaFMM","text":"Calls ExaFMM to solve for the vector potential field induced at every particle and the jacobian. The output has the following format\n\nOUTPUT:   npX(nparam+3+9*4) matrix OUT where OUT[i][1:nparam] is the input   parameters of the i-th particle, OUT[i][nparam+1:nparam+3] is the vector   potential at the position of the i-th particle, and   OUT[i][nparam+3+1:nparam+3+9] is the linearized jacobian,   OUT[i][nparam+3+9+1:nparam+3+9*2] is dJdx1,   OUT[i][nparam+3+9*2+1:nparam+3+9*3] is dJdx2,   OUT[i][nparam+3+9*3+1:nparam+3+9*4] is dJdx3,   OUT[i][nparam+3+9*4+1:n_param+3+9*4+3] is the particle strength exchange.\n\nNOTE: The particle order in OUT matches that of pfield.\n\n\n\n\n\n","category":"method"},{"location":"reference/VPMfunctions/#MyVPM.conv-Tuple{MyVPM.ParticleField,String}","page":"Functions Contained in MyVPM","title":"MyVPM.conv","text":"`conv(p_field, n; previous)`\n\nCalculates the convective term at each particle. Returns the Npx6 matrix M where M[i, 1:3] is the value of the convective term at the position of the i-th particle, M[i, 4:6] is the total velocity at the position of the i-th particle. If vorticity==true it will M will be Npx9 with M[i, 7:9] the vorticity at the position of the i-th particle.\n\n\n\n\n\n","category":"method"},{"location":"reference/VPMfunctions/#MyVPM.conv_ExaFMM-Tuple{MyVPM.ParticleField}","page":"Functions Contained in MyVPM","title":"MyVPM.conv_ExaFMM","text":"Calls ExaFMM to calculate induced velocity at every particle and corresponding convective term\n\n\n\n\n\n","category":"method"},{"location":"reference/VPMfunctions/#MyVPM.curlU-Tuple{MyVPM.ParticleField,Any}","page":"Functions Contained in MyVPM","title":"MyVPM.curlU","text":"Vorticity at X\n\n\n\n\n\n","category":"method"},{"location":"reference/VPMfunctions/#MyVPM.delparticle-Tuple{MyVPM.ParticleField,Int64}","page":"Functions Contained in MyVPM","title":"MyVPM.delparticle","text":"`delparticle(self, n)`\n\nDeletes the n-th particle in the field.\n\n\n\n\n\n","category":"method"},{"location":"reference/VPMfunctions/#MyVPM.error_divergencefree_Uw-Tuple{MyVPM.ParticleField}","page":"Functions Contained in MyVPM","title":"MyVPM.error_divergencefree_Uw","text":"Returns the sum of vector-potential velocity gradients over each particle's position\n\n\n\n\n\n","category":"method"},{"location":"reference/VPMfunctions/#MyVPM.error_divergencefree_w-Tuple{MyVPM.ParticleField}","page":"Functions Contained in MyVPM","title":"MyVPM.error_divergencefree_w","text":"Returns the sum of vorticity gradients over each particle's position\n\n\n\n\n\n","category":"method"},{"location":"reference/VPMfunctions/#MyVPM.get_gamma-Tuple{MyVPM.ParticleField,Int64}","page":"Functions Contained in MyVPM","title":"MyVPM.get_gamma","text":"Returns the vectorial circulation of the n-th particle\n\n\n\n\n\n","category":"method"},{"location":"reference/VPMfunctions/#MyVPM.get_np-Tuple{MyVPM.ParticleField}","page":"Functions Contained in MyVPM","title":"MyVPM.get_np","text":"Returns the current number of particles\n\n\n\n\n\n","category":"method"},{"location":"reference/VPMfunctions/#MyVPM.get_particle-Tuple{MyVPM.ParticleField,Int64}","page":"Functions Contained in MyVPM","title":"MyVPM.get_particle","text":"Returns the n-th particle\n\n\n\n\n\n","category":"method"},{"location":"reference/VPMfunctions/#MyVPM.get_sigma-Tuple{MyVPM.ParticleField,Int64}","page":"Functions Contained in MyVPM","title":"MyVPM.get_sigma","text":"Returns the blob radius of the n-th particle\n\n\n\n\n\n","category":"method"},{"location":"reference/VPMfunctions/#MyVPM.get_vol-Tuple{MyVPM.ParticleField,Int64}","page":"Functions Contained in MyVPM","title":"MyVPM.get_vol","text":"Returns the blob radius of the n-th particle\n\n\n\n\n\n","category":"method"},{"location":"reference/VPMfunctions/#MyVPM.get_x-Tuple{MyVPM.ParticleField,Int64}","page":"Functions Contained in MyVPM","title":"MyVPM.get_x","text":"Returns the position vector of the n-th particle\n\n\n\n\n\n","category":"method"},{"location":"reference/VPMfunctions/#MyVPM.lagrangian_distortion-Tuple{MyVPM.ParticleField}","page":"Functions Contained in MyVPM","title":"MyVPM.lagrangian_distortion","text":"Adds particles to the field for fixing Lagrangian distortion and runs an RBF for finding the new strengths in the field.\n\n\n\n\n\n","category":"method"},{"location":"reference/VPMfunctions/#MyVPM.nextstep-Tuple{MyVPM.ParticleField,Float64}","page":"Functions Contained in MyVPM","title":"MyVPM.nextstep","text":"`nextstep(p_field, dt)`\n\nSteps the field forward in time by dt. Use Uprobes to probe the velocity at any set of points. Give it relax=true to relax the discretized vorticity field back to a divergence-free field in this step.\n\n\n\n\n\n","category":"method"},{"location":"reference/VPMfunctions/#MyVPM.rbf_cg-Union{Tuple{T}, Tuple{MyVPM.ParticleField,Array{Array{T,1},1}}} where T<:Real","page":"Functions Contained in MyVPM","title":"MyVPM.rbf_cg","text":"Radial basis function interpolation of Gamma using the conjugate gradient method. This method only works on a particle field with uniform smoothing radius sigma.\n\n\n\n\n\n","category":"method"},{"location":"reference/VPMfunctions/#MyVPM.read-Tuple{String,Any,Any}","page":"Functions Contained in MyVPM","title":"MyVPM.read","text":"Reads and returns a particle field .jld\n\n\n\n\n\n","category":"method"},{"location":"reference/VPMfunctions/#MyVPM.read_vtk-Tuple{String,Any,Any}","page":"Functions Contained in MyVPM","title":"MyVPM.read_vtk","text":"Reads and returns a particle field from a .vtk\n\n\n\n\n\n","category":"method"},{"location":"reference/VPMfunctions/#MyVPM.reg_UomegaBarba-Tuple{MyVPM.ParticleField,Any}","page":"Functions Contained in MyVPM","title":"MyVPM.reg_UomegaBarba","text":"Direct calculation of induced velocity as a regularized Biot-Savart kernel using a Gaussian regularization\n\n\n\n\n\n","category":"method"},{"location":"reference/VPMfunctions/#MyVPM.reg_UomegaGharakhani-Tuple{MyVPM.ParticleField,Any}","page":"Functions Contained in MyVPM","title":"MyVPM.reg_UomegaGharakhani","text":"Direct calculation of induced velocity as a regularized Biot-Savart kernel using the Gharakhani's Gaussian regularization\n\n\n\n\n\n","category":"method"},{"location":"reference/VPMfunctions/#MyVPM.reg_UomegaWinckelmann-Tuple{MyVPM.ParticleField,Any}","page":"Functions Contained in MyVPM","title":"MyVPM.reg_UomegaWinckelmann","text":"Direct calculation of induced velocity as a regularized Biot-Savart kernel using Winckelmann's regularization\n\n\n\n\n\n","category":"method"},{"location":"reference/VPMfunctions/#MyVPM.reg_Utot-Tuple{MyVPM.ParticleField,Any}","page":"Functions Contained in MyVPM","title":"MyVPM.reg_Utot","text":"Total velocity at position X at the current time with the singular kernel\n\n\n\n\n\n","category":"method"},{"location":"reference/VPMfunctions/#MyVPM.run_vpm!-Tuple{MyVPM.ParticleField,Float64,Int64}","page":"Functions Contained in MyVPM","title":"MyVPM.run_vpm!","text":"run_vpm!(p_field, dt, nsteps; runtime_function=nothing,\n              save_path=nothing, run_name=\"pfield\", nsteps_save=1,\n              save_code=\"\", prompt=true)\n\nSolves nsteps of the particle field with a time step of dt.\n\nOptional Arguments\n\nruntime_function::Any   : Give it a function of the form                             myfun(pfield, t, dt). On each time step it                             will call this function. Use this for adding                             particles, deleting particles, etc.\nsolver_method::String   : Solver method (ExaFMM, direct, directblob).\nnsteps_relax::Int64 : Relaxes the particle field every this many time steps.\nsave_path::Any      : Give it a string for saving VTKs of the particle                         field. Creates the given path.\nrun_name::String    : Suffix of vtk files.\nnsteps_save::Int64  : Saves vtks every this many time steps.\nsave_code::String   : Give it the name of a file and it will save make a                         copy of this file along with the vtks. Use this for                         backing up whatever code is used for generating this                         run.\nprompt::Bool        : If save_path already exist, it will prompt the                         user before overwritting the folder if true; it will                         directly overwrite it if false.\nverbose::Bool       : Prints progress of the run to the terminal.\nverbose_nsteps::Bool: Number of time steps between verbose.\nparallel_Uphi::Bool : Flag for evaluating Uphi in parallel.\ngroup_Uphi::Bool : Flag for evaluating Uphi as a group of points.\nbeta::Real          : Maximum core growth (sgm/sgm0) in CS scheme.\nsgm0::Real          : Reinitialization core size.\n\n\n\n\n\n","category":"method"},{"location":"reference/VPMfunctions/#MyVPM.save-Tuple{MyVPM.ParticleField,String}","page":"Functions Contained in MyVPM","title":"MyVPM.save","text":"Outputs the particle field as the file [file_name].jld\n\n\n\n\n\n","category":"method"},{"location":"reference/VPMfunctions/#MyVPM.save_vtk-Tuple{MyVPM.ParticleField,String}","page":"Functions Contained in MyVPM","title":"MyVPM.save_vtk","text":"save_field(p_field, filename; path=\"\", comment=\"\")\n\nSaves the particle field p_field as a vtk file.\n\n\n\n\n\n","category":"method"},{"location":"reference/VPMfunctions/#MyVPM.sing_Uomega-Tuple{MyVPM.ParticleField,Any}","page":"Functions Contained in MyVPM","title":"MyVPM.sing_Uomega","text":"Direct calculation of induced velocity as a singular Biot-Savart kernel\n\n\n\n\n\n","category":"method"},{"location":"reference/VPMfunctions/#MyVPM.sing_Utot-Tuple{MyVPM.ParticleField,Any}","page":"Functions Contained in MyVPM","title":"MyVPM.sing_Utot","text":"Total velocity at position X at the current time with the singular kernel\n\n\n\n\n\n","category":"method"},{"location":"reference/VPMfunctions/#MyVPM.zeta_ExaFMM-Tuple{MyVPM.ParticleField}","page":"Functions Contained in MyVPM","title":"MyVPM.zeta_ExaFMM","text":"Calls ExaFMM to calculate discretization function zeta at every particle\n\n\n\n\n\n","category":"method"},{"location":"reference/VPMfunctions/#MyVPM.ParticleField","page":"Functions Contained in MyVPM","title":"MyVPM.ParticleField","text":"ParticleField(n_max::Int64, Uinf, Uphi, method::String)\n\nInitializes a particle field where up to n_max particles can be added and computed, the undisturbed freestream is given by Uinf(X, t), and a scalar-potential induced velocity is given by Uphi(X, t). method defines the solver method (\"ExaFMM\"/\"direct\"/\"directblob\")\n\n\n\n\n\n","category":"type"},{"location":"how-to-guide/define-a-rotor/#How-to-Define-a-Custom-Rotor","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"","category":"section"},{"location":"how-to-guide/define-a-rotor/","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"It is likely that the rotors defined in the repository database do not match your needs, in that case, you will need to provide all of the information to define the rotor in a series of files. The files must be defined in the correct format and directory structure for FlowUnsteady to find it all. If you are unfamiliar with creating file trees, we suggest adding your files directly to the correct directories, however a seperate file structure can easily be used.","category":"page"},{"location":"how-to-guide/define-a-rotor/#Creating-a-Custom-Rotor","page":"How to Define a Custom Rotor","title":"Creating a Custom Rotor","text":"","category":"section"},{"location":"how-to-guide/define-a-rotor/","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"If you do not already have the rotor files to describe your rotor, then you will need to create them. Here we will go through each file type and what to put in them. It is important to note that file name and types are not important, however they must be comma delimited.  We will use the DJI-II from the FLOWUnsteady database as an example.","category":"page"},{"location":"how-to-guide/define-a-rotor/","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"It is important to note that if XFOIL is not run (marked false), then airfoil polars must be provided. The files that affect solution outcome are the chord distribution, pitch distribution, leading edge distribution, and airfoil polar files. If XFOIL is marked to run, all of the geometric material must be accurate.","category":"page"},{"location":"how-to-guide/define-a-rotor/","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"Below, we describe the files (and give the default file name), their contents, and provide code that can be used to create them.","category":"page"},{"location":"how-to-guide/define-a-rotor/#Main-File-(e.g.-data/rotors/DJI-II.csv)","page":"How to Define a Custom Rotor","title":"Main File (e.g. data/rotors/DJI-II.csv)","text":"","category":"section"},{"location":"how-to-guide/define-a-rotor/","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"The main file describes the overall rotor, and points to the blade file that describes one of the blades.","category":"page"},{"location":"how-to-guide/define-a-rotor/","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"property file description\nRtip 0.12 (m) Radius of blade tip\nRhub 0.00823 (m) Radius of hub\nB 2 Number of blades\nblade DJI-II_blade.csv Blade file","category":"page"},{"location":"how-to-guide/define-a-rotor/#Blade-File-(e.g.-data/rotors/DJI-II_blade.csv)","page":"How to Define a Custom Rotor","title":"Blade File (e.g. data/rotors/DJI-II_blade.csv)","text":"","category":"section"},{"location":"how-to-guide/define-a-rotor/","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"This file contains file names for the various blade definition parameters as well as parameters for spline definitions.","category":"page"},{"location":"how-to-guide/define-a-rotor/","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"property file description\nchorddist DJI-II_chorddist.csv Chord distribution\npitchdist DJI-II_pitchdist.csv Pitch distribution\nsweepdist DJI-II_sweepdist.csv LE sweep distribution\nheightdist DJI-II_heightdist.csv LE height distribution\nairfoil_files DJI-II_airfoils.csv Airfoil distribution\nspl_k 1 Spline order\nspl_s 2.0e-7 Spline smoothing","category":"page"},{"location":"how-to-guide/define-a-rotor/#Chord-Distribution-File-(e.g.-data/rotors/DJI-II_chorddist.csv)","page":"How to Define a Custom Rotor","title":"Chord Distribution File (e.g. data/rotors/DJI-II_chorddist.csv)","text":"","category":"section"},{"location":"how-to-guide/define-a-rotor/","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"This file provides the distribution of the chord along the blade, normalized by the tip radius of the blade. The file must go in order from root to tip. The root need not be defined, but the tip must be. The file can have any number of paired numbers. Any values used by the solver that are not provided will be interpolated.","category":"page"},{"location":"how-to-guide/define-a-rotor/","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"r/R c/R\n0.0411523 0.121011\n0.0685871 0.138171\n... ...\n1.0 0.0978361","category":"page"},{"location":"how-to-guide/define-a-rotor/#Pitch-Distribution-File-(e.g.-data/rotors/DJI-II_pitchdist.csv)","page":"How to Define a Custom Rotor","title":"Pitch Distribution File (e.g. data/rotors/DJI-II_pitchdist.csv)","text":"","category":"section"},{"location":"how-to-guide/define-a-rotor/","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"This file describes the twist of the blade along the blade. The file can have any number of paired numbers. Any values used by the solver that are not provided will be interpolated.","category":"page"},{"location":"how-to-guide/define-a-rotor/","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"r/R twist (deg)\n0.0411523 16.4567\n0.0685871 17.5\n... ...\n1.0 11.6","category":"page"},{"location":"how-to-guide/define-a-rotor/#Sweep-Distribution-File-(e.g.-data/rotors/DJI-II_sweepdist.csv)","page":"How to Define a Custom Rotor","title":"Sweep Distribution File (e.g. data/rotors/DJI-II_sweepdist.csv)","text":"","category":"section"},{"location":"how-to-guide/define-a-rotor/","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"This file describes the sweep distribution. This is also known as the leading edge distribution, it describes the distance of the the leading edge from a line coming from the center of the hub. These lines change depending on how many blades are included on a rotor (see photo below for example of a the rotor with 3 blades). The file can have any number of paired numbers. Any values used by the solver that are not provided will be interpolated.","category":"page"},{"location":"how-to-guide/define-a-rotor/","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"<img src=\"../assets/howtofigs/sweepdist.png\" alt=\"sweepdist\" style=\"zoom:33%;\" />","category":"page"},{"location":"how-to-guide/define-a-rotor/","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"r/R y/R (y-distance of LE from the middle point of hub)\n0.0411523 0.0576211\n0.0685871 0.0605955\n... ...\n1.0 0.0344412","category":"page"},{"location":"how-to-guide/define-a-rotor/#Height-Distribution-File-(e.g.-data/rotors/DJI-II_heightdist.csv)","page":"How to Define a Custom Rotor","title":"Height Distribution File (e.g. data/rotors/DJI-II_heightdist.csv)","text":"","category":"section"},{"location":"how-to-guide/define-a-rotor/","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"This file describes the height distribution, also known as anhedral (or precode for turbines). This describes the height of the leading edge from the top face of the hub. The file can have any number of paired numbers. Any values used by the solver that are not provided will be interpolated.","category":"page"},{"location":"how-to-guide/define-a-rotor/","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"<img src=\"../assets/howtofigs/precone.png\" alt=\"precone\" width=\"400\" />","category":"page"},{"location":"how-to-guide/define-a-rotor/","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"r/R z/R (height of LE from the top face of hub)\n0.0686391 -0.00242965\n0.2 0.00728895\n... ...\n1.0 -0.0242965","category":"page"},{"location":"how-to-guide/define-a-rotor/#Airfoil-Section-Definition-File-(e.g.-data/rotors/DJI-II_airfoils.csv)","page":"How to Define a Custom Rotor","title":"Airfoil Section Definition File (e.g. data/rotors/DJI-II_airfoils.csv)","text":"","category":"section"},{"location":"how-to-guide/define-a-rotor/","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"This file describes the airfoils along the blade and the paired aerodynamic data file that goes with the contour file. The contour file is a file of the geometric shape of the airfoil. The aero file is the airfoil polar, that is, the file that has the coefficient of lift, drag and moment for a given set of angles of attack for the airfoil. Note that the information is interpolated, so airfoils between two stated airfoils will be an interpolation between the two. If XFOIL is marked to run, then the aero files will not be used. As many pairs of airfoil files as desired may be used.","category":"page"},{"location":"how-to-guide/define-a-rotor/","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"r/R Contour file Aero file\n0.0 e856-il.csv xf-e856-il-50000-n5.csv\n0.3 e63.csv xf-e63-il-50000-n5.csv\n1.0 e63.csv xf-e63-il-50000-n5.csv","category":"page"},{"location":"how-to-guide/define-a-rotor/#Airfoil-Geometry-Files-(e.g.-data/airfoils/e63.csv)","page":"How to Define a Custom Rotor","title":"Airfoil Geometry Files (e.g. data/airfoils/e63.csv)","text":"","category":"section"},{"location":"how-to-guide/define-a-rotor/","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"These files describes the geometry of the airfoil by giving x and y coordinates of the airfoil surface. These coordinates are normalized by the chord length. The order of the points should be trailing edge, upper surface, leading edge, lower surface, then trailing edge. As many coordinate pairs as desired may be used, all other points used will be interpolated.","category":"page"},{"location":"how-to-guide/define-a-rotor/","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"x/c y/c\n1.0 0.0\n0.99619 0.00144\n... ...\n1.0 0.0","category":"page"},{"location":"how-to-guide/define-a-rotor/#Airfoil-Polar-Files-(e.g.-data/airfoils/xf-e63-il-50000-n5.csv)","page":"How to Define a Custom Rotor","title":"Airfoil Polar Files (e.g. data/airfoils/xf-e63-il-50000-n5.csv)","text":"","category":"section"},{"location":"how-to-guide/define-a-rotor/","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"These files contains all of the airfoil coefficients of lift, drag and moment for a given set of angles of attack for the airfoil. Values that are required but not given will be interpolated. Note that the polar should match the general Reynolds number that the given section will experience. If XFOIL is set to run, this file will not be used.","category":"page"},{"location":"how-to-guide/define-a-rotor/","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"Alpha Cl Cd Cdp Cm Top_Xtr Bot_Xtr\n-7.750 -0.3633 0.11634 0.10945 -0.0220 1.0000 0.0585\n-7.500 -0.3685 0.11553 0.10875 -0.0216 1.0000 0.0590\n-7.250 -0.3745 0.11473 0.10806 -0.0210 1.0000 0.0593\n... ... ... ... ... ... ...\n10.750 1.3119 0.10187 0.09684 -0.1098 0.0306 1.0000","category":"page"},{"location":"how-to-guide/define-a-rotor/#Rotor-Database-Structure","page":"How to Define a Custom Rotor","title":"Rotor Database Structure","text":"","category":"section"},{"location":"how-to-guide/define-a-rotor/","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"The database can be found as a subdirectory of the FlowUnsteady package","category":"page"},{"location":"how-to-guide/define-a-rotor/","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"../FlowUnsteady/data","category":"page"},{"location":"how-to-guide/define-a-rotor/","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"It takes the form","category":"page"},{"location":"how-to-guide/define-a-rotor/","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"MainFile.csv => ../data/rotors\nAirfoils.csv => ../data/rotors\nBlade.csv => ../data/rotors\nChordDist.csv => ../data/rotors\nHeightDist.csv => ../data/rotors\nPitchDist.csv => ../data/rotors\nSweepDist.csv => ../data/rotors\nAirfoilGeo_1.csv => ../data/airfoils\nAirfoilGeo_2.csv => ../data/airfoils\nAirfoilGeo_n.csv => ../data/airfoils\nAirfoilPol_1.dat => ../data/airfoils\nAirfoilPol_2.dat => ../data/airfoils\nAirfoilPol_n.dat => ../data/airfoils","category":"page"},{"location":"how-to-guide/define-a-rotor/","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"You can point the solver to any data path, but within that data directory, you must have your files organized as above, with a rotors and airfoils subdirectory and the appropriate files in the appropriate locations.","category":"page"},{"location":"how-to-guide/define-a-rotor/#Creating-Custom-Database-Files","page":"How to Define a Custom Rotor","title":"Creating Custom Database Files","text":"","category":"section"},{"location":"how-to-guide/define-a-rotor/","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"The following is an example script for creating all the necessary files in the rotor sub-directory.  Note, however, that you need to provide your own geometry and polar files to populate the airfoils sub-directory.  How you produce those is up to you, but as far as the polars are concerned, our format matches that of the XFoil output files.","category":"page"},{"location":"how-to-guide/define-a-rotor/","page":"How to Define a Custom Rotor","title":"How to Define a Custom Rotor","text":"## ----- Define Rotor Parameters ----- ##\nRPM     = 4860\nrho     = 1.225     # (kg/m^3) air density\nB       = 3         # Number of blades\nRhub    = 0.212     # (m) Radius of hub\nRtip    = 1.0       # (m) Radius of blade tip\nctip    = 0.05      # (m) tip chord length\ncroot   = .15       # (m) chord length at hub junction\nr       = range(Rhub, Rtip, length=100)         #radial stations\nrs      = range(Rhub, Rtip, length=100)./Rtip   #normalized radial stations\n\n#define chord distribution\nchord = zeros(length(r))\nfor i=1:length(r)\n    if r[i] <= 0.5*Rtip\n        chord[i] = croot\n    else\n        chord[i] = ctip + sqrt(1.0-(2*r[i]-1)^2.0)/10.0\n    end\nend\n\nchorddist = hcat(rs,chord)  #chord distribution\n\n#define pitch distribution\na1, a2  = 10, 30\nr1, r2  = 1.0, 0.225\nb       = (a2 - a1) / (1/r2 - 1/r1)\na       = a1 - b/r1\n\nth0     = 0.33200247373618086\ndthdr   = -0.28443616547899253\n\npitchdist   = hcat(rs, th0 + dthdr.*rs)     #pitch distribution\n\n#define remaining distributions\nXles        = zeros(length(rs))             #leading edge distribution\nsweepdist   = hcat(rs, Xles )               #sweep distribution\nheightdist  = hcat(rs, zeros(length(rs)) )  #height distribution\n\n\n\n## ----- Name Files ----- ##\nairfoil_file        = \"airfoils/naca0012.csv\"\ndata_path1          = \"data/rotors/\"\nsave_path1          = \"rotors\"\nrun_name            = \"rotoroldformat_try2\"\n\nrotor_filename      = \"rotorfile.csv\"\nblade_filename      = \"blade.csv\"\nairfoils_filename   = \"airfoils.csv\"\nhdist_filename      = \"heightdist.csv\"\nsdist_filename      = \"sweepdist.csv\"\npdist_filename      = \"pitchdist.csv\"\ncdist_filename      = \"chorddist.csv\"\n\n\n\n## ---- Write Files ----- ##\nrotorstring = \"property,file,description\nRtip,$Rtip, (m) Radius of blade tip\nRhub,$Rhub, (m) Radius of hub\nB,$B, Number of blades\nblade,$blade_filename, Blade file\"\n\n# Main File\nf = open(joinpath(data_path1, rotor_filename), \"w\")\nwrite(f, rotorstring)\nclose(f)\n\nbladestring = \"property,file,description\nchorddist,$cdist_filename, Chord distribution\npitchdist,$pdist_filename, Pitch distribution\nsweepdist,$sdist_filename, LE sweep distribution\nheightdist,$hdist_filename, LE height distribution\nairfoil_files,$airfoils_filename, Airfoil distribution\nspl_k,4,  Spline order\nspl_s,5.0e-7, Spline smoothing\"\n\n# Blade File\nf = open(joinpath(data_path1, blade_filename), \"w\")\nwrite(f, bladestring)\nclose(f)\n\n# Chord Distribution File\nchordstring = \"r/R,c/R\\n\"\nf = open(joinpath(data_path1, cdist_filename), \"w\")\nwrite(f, chordstring)\nfor i=1:length(r)\n    write(f,\"$(chorddist[i,1]),$(chorddist[i,2])\\n\")\nend\nclose(f)\n\n# Height Distribution File\nheightstring = \"r/R,z/R  (height of leading edge from top face of hub)\\n\"\nf = open(joinpath(data_path1, hdist_filename), \"w\")\nwrite(f, heightstring)\nfor i=1:length(r)\n    write(f,\"$(heightdist[i,1]),$(heightdist[i,2])\\n\")\nend\nclose(f)\n\n# Pitch Distribution File\npitchstring = \"r/R,twist (deg)\\n\"\nf = open(joinpath(data_path1, pdist_filename), \"w\")\nwrite(f, pitchstring)\nfor i=1:length(r)\n    write(f,\"$(pitchdist[i,1]),$(pitchdist[i,2])\\n\")\nend\nclose(f)\n\n#Sweep (Leading Edge) Distribution File\nsweepstring = \"r/R,twist (deg)\\n\"\nf = open(joinpath(data_path1, sdist_filename), \"w\")\nwrite(f, sweepstring)\nfor i=1:length(r)\n    write(f,\"$(sweepdist[i,1]),$(sweepdist[i,2])\\n\")\nend\nclose(f)\n\n# Airfoil Section Definition File\nairfoilstring = \"r/R,Contour file,Aero file\n0.0,naca0012.csv,naca0012polarabrev.csv\n1.0,naca0012.csv,naca0012polarabrev.csv\"\nf = open(joinpath(data_path1, airfoils_filename), \"w\")\nwrite(f, airfoilstring)\nclose(f)","category":"page"},{"location":"theory/VPMtheory/#Vortex-Particle-Method","page":"Vortex Particle Method","title":"Vortex Particle Method","text":"","category":"section"},{"location":"how-to-guide/select-a-solver/#Select-a-Solver","page":"Select a Solver","title":"Select a Solver","text":"","category":"section"},{"location":"theory/FLOWUnsteadytheory/#FLOWUnsteady","page":"FLOWUnsteady","title":"FLOWUnsteady","text":"","category":"section"},{"location":"theory/FLOWUnsteadytheory/","page":"FLOWUnsteady","title":"FLOWUnsteady","text":"Pages = [\"FLOWUnsteady.md\"]","category":"page"},{"location":"#Welcome-to-FLOWUnsteady","page":"Home","title":"Welcome to FLOWUnsteady","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<img src=\"assets/img/blownwing00.png\" alt=\"Vid\" width=\"700px\"/>","category":"page"},{"location":"","page":"Home","title":"Home","text":"FLOWUnsteady is a simulation engine of mixed-fidelity unsteady aerodynamics and aeroacoustics. This suite brings together mid and high-fidelity aerodynamics tools developed at BYU's FLOW Lab: GeometricTools (geometric engine), FLOWVLM (VLM and strip theory solver), CCBlade (blade element momentum solver), MyPanel (3D inviscid panel solver), and FLOWVPM (viscous vortex particle method). The aeroacoustic solver integrates PSU-WOPWOP (FW-H solver) and FLOWNoise (BPM code).","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you are brand-new to FLOWUnsteady, you should begin with our Getting Started guide in the Tutorials.  You may then consider taking a glance at how to Visualize with Paraview in order to be prepared to visualize as you go. After getting the code set up, you'll be able to take your First Steps with FLOWUnsteady.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For additional validation and numerical recommendations, check this notebook: docs/resources/validation.ipynb.\nFor example simulations, check this notebook: docs/resources/examples.ipynb.\nFor an example and validation of aeroacoustics, check this notebook: examples/rotornoise/singlerotor.ipynb.\nSOURCE CODE: https://github.com/byuflowlab/FLOWUnsteady","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Vortex particle method (VPM) solver\nAll aerodynamics codes used in FLOWUnsteady are opensource and available in Github, except for the VPM solver. Without the VPM, the user can still use all quasi-steady aerodynamic and aeroacoustic solvers in FLOWUnsteady. To get full access to the unsteady solver, please contact Ed Alvarez (edoalvarez.com) or the FLOW Lab (flow.byu.edu).","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Julia language\nThis package was written in Julia 1.4.2.","category":"page"},{"location":"","page":"Home","title":"Home","text":"FEATURES","category":"page"},{"location":"","page":"Home","title":"Home","text":"Viscous, unsteady wake mixing of rotors and lifting surfaces.\nFully resolved rotor-on-rotor, rotor-on-wing, wing-on-rotor, and wing-on-wing","category":"page"},{"location":"","page":"Home","title":"Home","text":"interactions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Fully resolved unsteady loads during prescribed kinematic maneuvers.","category":"page"},{"location":"","page":"Home","title":"Home","text":"LIMITATIONS","category":"page"},{"location":"","page":"Home","title":"Home","text":"Viscous drag and separation is only captured through strip theory, without","category":"page"},{"location":"","page":"Home","title":"Home","text":"attempting to shed separation wakes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"No viscous drag is captured through VLM and panel models.","category":"page"},{"location":"","page":"Home","title":"Home","text":"FUTURE WORK","category":"page"},{"location":"","page":"Home","title":"Home","text":"Coupling of aerodynamic loads and flight path allowing dynamic simulations.\nBluff body separation and panel-predicted viscous drag (?).","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HEAVING WING: examples/heavingwing.jl (Image: Vid)","category":"page"},{"location":"","page":"Home","title":"Home","text":"CROSS-WIND CIRCULAR PATH: examples/circularpath.jl (Image: Vid)","category":"page"},{"location":"","page":"Home","title":"Home","text":"HOVERING ROTOR: examples/singlerotor.jl (Image: Vid)","category":"page"},{"location":"","page":"Home","title":"Home","text":"INTERACTING TANDEM HEAVING WING: examples/tandemheavingwing.jl (Image: Vid here)","category":"page"},{"location":"","page":"Home","title":"Home","text":"BLOWN WING: examples/blownwing/blownwing.jl (Image: Vid here)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Wind-harvesting Aircraft: examples/windcraft/windcraft.jl (in progress) (Image: Vid here)","category":"page"},{"location":"","page":"Home","title":"Home","text":"eVTOL TRANSITION: examples/vahana/vahana.jl (in progress) (Image: Vid here)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Rotor Aeroacoustic Noise: examples/rotornoise/singlerotor.ipynb","category":"page"},{"location":"","page":"Home","title":"Home","text":"<img src=\"assets/img/rotornoise01.png\" alt=\"Vid\" width=\"400px\"/>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<img src=\"assets/vid/cfdnoise_ningdji_multi_005D_03_15.gif\" alt=\"Vid\" width=\"600px\"/>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<img src=\"assets/vid/cfdnoise_ningdji_multi_005D_03_18.gif\" alt=\"Vid\" width=\"600px\"/>","category":"page"},{"location":"#Framework-Flowchart","page":"Home","title":"Framework Flowchart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Img)","category":"page"},{"location":"#Publications","page":"Home","title":"Publications","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Alvarez, E. J., & Ning, A. (2021, in progress). Unsteady Mixed-fidelity Aerodynamics Solver for Maneuvering Multirotor Aircraft. AIAA SciTech Forum. [PDF]\nAlvarez, E. J., Schenk, A., Critchfield, T., and Ning, A. (2020, in review). Rotor-on-Rotor Aeroacoustic Interactions of Multirotor in Hover. Journal of the American Helicopter Society.\nAlvarez, E. J., (2020). Quasi-steady Aerodynamics Solver for a High-fidelity Controls Framework. FLOWUnsteady Documentation. [PDF]\nAlvarez, E. J., & Ning, A. (2020, accepted). High-fidelity Modeling of Multirotor Aerodynamic Interactions for Aircraft Design. AIAA Journal. [PDF]\nAlvarez, E. J., & Ning, A. (2019). Modeling Multirotor Aerodynamic Interactions Through the Vortex Particle Method. AIAA AVIATION Forum. DOI: 10.2514/6.2019-2827[SLIDES][PDF]\nAlvarez, E. J., & Ning, A. (2018). Development of a Vortex Particle Code for the Modeling of Wake Interaction in Distributed Propulsion. AIAA AVIATION Forum. DOI: 10.2514/6.2018-3646[SLIDES][PDF]","category":"page"},{"location":"#Authorship","page":"Home","title":"Authorship","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Main developer    : Eduardo J Alvarez\nEmail             : Edo.AlvarezR@gmail.com\nWebsite           : edoalvarez.com\nCreated           : Oct 2019\nLicense           : MIT License","category":"page"}]
}
